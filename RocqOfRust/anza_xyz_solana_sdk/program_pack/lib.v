(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

(* Trait *)
(* Empty module 'IsInitialized' *)

(* Trait *)
(* Empty module 'Sealed' *)

(* Trait *)
Module Pack.
  Definition get_packed_len
      (Self : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.read (| get_constant (| "solana_program_pack::Pack::LEN", Ty.path "usize" |) |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom ProvidedMethod_get_packed_len :
    M.IsProvidedMethod "solana_program_pack::Pack" "get_packed_len" get_packed_len.
  Definition unpack (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ input ] =>
      ltac:(M.monadic
        (let input :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            input
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Self; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ value : Self :=
                M.match_operator (|
                  Self,
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::ops::control_flow::ControlFlow")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::convert::Infallible";
                            Ty.path "solana_program_error::ProgramError"
                          ];
                        Self
                      ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "solana_program_error::ProgramError"
                            ];
                          Self
                        ],
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Self; Ty.path "solana_program_error::ProgramError" ],
                        [],
                        [],
                        "branch",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Self; Ty.path "solana_program_error::ProgramError" ],
                          M.get_trait_method (|
                            "solana_program_pack::Pack",
                            Self,
                            [],
                            [],
                            "unpack_unchecked",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "core::convert::Infallible";
                                Ty.path "solana_program_error::ProgramError"
                              ],
                            γ0_0
                          |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Self; Ty.path "solana_program_error::ProgramError" ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Self; Ty.path "solana_program_error::ProgramError" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "solana_program_error::ProgramError"
                                      ]
                                  ],
                                  "from_residual",
                                  [],
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| Self, γ0_0 |) in
                        M.read (| val |)))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Self; Ty.path "solana_program_error::ProgramError" ],
                M.match_operator (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Self; Ty.path "solana_program_error::ProgramError" ],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "solana_program_pack::IsInitialized",
                                  Self,
                                  [],
                                  [],
                                  "is_initialized",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, value |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [ Self; Ty.path "solana_program_error::ProgramError" ]
                          [ M.read (| value |) ]));
                    fun γ =>
                      ltac:(M.monadic
                        (Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [ Self; Ty.path "solana_program_error::ProgramError" ]
                          [
                            Value.StructTuple
                              "solana_program_error::ProgramError::UninitializedAccount"
                              []
                              []
                              []
                          ]))
                  ]
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom ProvidedMethod_unpack : M.IsProvidedMethod "solana_program_pack::Pack" "unpack" unpack.
  Definition unpack_unchecked
      (Self : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ input ] =>
      ltac:(M.monadic
        (let input :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            input
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Self; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ne,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| input |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    get_constant (|
                                      "solana_program_pack::Pack::LEN",
                                      Ty.path "usize"
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Self; Ty.path "solana_program_error::ProgramError" ]
                                [
                                  Value.StructTuple
                                    "solana_program_error::ProgramError::InvalidAccountData"
                                    []
                                    []
                                    []
                                ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Self; Ty.path "solana_program_error::ProgramError" ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Self; Ty.path "solana_program_error::ProgramError" ],
                  M.get_trait_method (|
                    "solana_program_pack::Pack",
                    Self,
                    [],
                    [],
                    "unpack_from_slice",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |) ]
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom ProvidedMethod_unpack_unchecked :
    M.IsProvidedMethod "solana_program_pack::Pack" "unpack_unchecked" unpack_unchecked.
  Definition pack (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ src; dst ] =>
      ltac:(M.monadic
        (let src := M.alloc (| Self, src |) in
        let dst :=
          M.alloc (|
            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            dst
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ne,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| dst |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    get_constant (|
                                      "solana_program_pack::Pack::LEN",
                                      Ty.path "usize"
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                                [
                                  Value.StructTuple
                                    "solana_program_error::ProgramError::InvalidAccountData"
                                    []
                                    []
                                    []
                                ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "solana_program_pack::Pack",
                    Self,
                    [],
                    [],
                    "pack_into_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, src |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                  [ Value.Tuple [] ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom ProvidedMethod_pack : M.IsProvidedMethod "solana_program_pack::Pack" "pack" pack.
End Pack.
