(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

Definition value_ADDRESS_BYTES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 32 |))).

Global Instance Instance_IsConstant_value_ADDRESS_BYTES :
  M.IsFunction.C "solana_address::ADDRESS_BYTES" value_ADDRESS_BYTES.
Admitted.
Global Typeclasses Opaque value_ADDRESS_BYTES.

Definition value_MAX_SEED_LEN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 32 |))).

Global Instance Instance_IsConstant_value_MAX_SEED_LEN :
  M.IsFunction.C "solana_address::MAX_SEED_LEN" value_MAX_SEED_LEN.
Admitted.
Global Typeclasses Opaque value_MAX_SEED_LEN.

Definition value_MAX_SEEDS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 16 |))).

Global Instance Instance_IsConstant_value_MAX_SEEDS :
  M.IsFunction.C "solana_address::MAX_SEEDS" value_MAX_SEEDS.
Admitted.
Global Typeclasses Opaque value_MAX_SEEDS.

(* StructTuple
  {
    name := "Address";
    const_params := [];
    ty_params := [];
    fields :=
      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] ];
  } *)

Module Impl_core_clone_Clone_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (* Clone *)
  Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        M.match_operator (|
          Ty.path "solana_address::Address",
          Value.DeclaredButUndefined,
          [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_solana_address_Address.

Module Impl_core_marker_Copy_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_core_marker_Copy_for_solana_address_Address.

Module Impl_core_default_Default_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (* Default *)
  Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (Value.StructTuple
          "solana_address::Address"
          []
          []
          [
            M.call_closure (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
              M.get_trait_method (|
                "core::default::Default",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
                [],
                [],
                "default",
                [],
                []
              |),
              []
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_solana_address_Address.

Module Impl_core_cmp_Eq_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (* Eq *)
  Definition assert_receiver_is_total_eq
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        M.match_operator (|
          Ty.tuple [],
          Value.DeclaredButUndefined,
          [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *)
      [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_solana_address_Address.

Module Impl_core_cmp_Ord_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (* Ord *)
  Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        let other :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], other |) in
        M.call_closure (|
          Ty.path "core::cmp::Ordering",
          M.get_trait_method (|
            "core::cmp::Ord",
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
            [],
            [],
            "cmp",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "solana_address::Address",
                    0
                  |)
                |)
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "solana_address::Address",
                    0
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Ord"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
End Impl_core_cmp_Ord_for_solana_address_Address.

Module Impl_core_marker_StructuralPartialEq_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_solana_address_Address.

Module Impl_core_cmp_PartialEq_solana_address_Address_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (* PartialEq *)
  Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        let other :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], other |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_trait_method (|
            "core::cmp::PartialEq",
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
            [],
            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] ],
            "eq",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "solana_address::Address",
                0
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| other |) |),
                "solana_address::Address",
                0
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "solana_address::Address" ]
      Self
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_solana_address_Address_for_solana_address_Address.

Module Impl_core_cmp_PartialOrd_solana_address_Address_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (* PartialOrd *)
  Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        let other :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], other |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
          M.get_trait_method (|
            "core::cmp::PartialOrd",
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
            [],
            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] ],
            "partial_cmp",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "solana_address::Address",
                    0
                  |)
                |)
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "solana_address::Address",
                    0
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialOrd"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "solana_address::Address" ]
      Self
      (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
End Impl_core_cmp_PartialOrd_solana_address_Address_for_solana_address_Address.

Module Impl_core_hash_Hash_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*
      fn hash<H: Hasher>(&self, state: &mut H) {
          state.write(self.as_array());
      }
  *)
  Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ H ], [ self; state ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ H ], state |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          [ Ty.path "u8" ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                [ Ty.path "u8" ]
                            ],
                          M.get_associated_function (|
                            Ty.path "solana_address::Address",
                            "as_array",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::hash::Hash"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_core_hash_Hash_for_solana_address_Address.

Module Impl_core_convert_From_ref__solana_address_Address_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*
      fn from(value: &Address) -> Self {
          *value
      }
  *)
  Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ value ] =>
      ltac:(M.monadic
        (let value :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], value |) in
        M.read (| M.deref (| M.read (| value |) |) |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *)
      [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ]
      Self
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_ref__solana_address_Address_for_solana_address_Address.

Module Impl_core_convert_From_array_Usize_32_u8_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*
      fn from(from: [u8; 32]) -> Self {
          Self(from)
      }
  *)
  Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ from ] =>
      ltac:(M.monadic
        (let from :=
          M.alloc (|
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
            from
          |) in
        Value.StructTuple "solana_address::Address" [] [] [ M.read (| from |) ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *)
      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] ]
      Self
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_array_Usize_32_u8_for_solana_address_Address.

Module Impl_core_convert_TryFrom_ref__slice_u8_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*     type Error = array::TryFromSliceError; *)
  Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
  
  (*
      fn try_from(address: &[u8]) -> Result<Self, Self::Error> {
          <[u8; 32]>::try_from(address).map(Self::from)
      }
  *)
  Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            address
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.path "solana_address::Address"; Ty.path "core::array::TryFromSliceError" ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ];
                Ty.path "core::array::TryFromSliceError"
              ],
            "map",
            [],
            [
              Ty.path "solana_address::Address";
              Ty.function
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ]
                ]
                (Ty.path "solana_address::Address")
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [ Ty.path "u8" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_trait_method (|
                "core::convert::TryFrom",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                "try_from",
                [],
                []
              |),
              [ M.read (| address |) ]
            |);
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "solana_address::Address",
              [],
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ]
              ],
              "from",
              [],
              []
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::TryFrom"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *)
      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
      Self
      (* Instance *)
      [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
End Impl_core_convert_TryFrom_ref__slice_u8_for_solana_address_Address.

Module Impl_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*
      pub const fn new_from_array(address_array: [u8; 32]) -> Self {
          Self(address_array)
      }
  *)
  Definition new_from_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address_array ] =>
      ltac:(M.monadic
        (let address_array :=
          M.alloc (|
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
            address_array
          |) in
        Value.StructTuple "solana_address::Address" [] [] [ M.read (| address_array |) ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_new_from_array :
    M.IsAssociatedFunction.C Self "new_from_array" new_from_array.
  Admitted.
  Global Typeclasses Opaque new_from_array.
  
  (*
      pub const fn to_bytes(self) -> [u8; 32] {
          self.0
      }
  *)
  Definition to_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| Ty.path "solana_address::Address", self |) in
        M.read (| M.SubPointer.get_struct_tuple_field (| self, "solana_address::Address", 0 |) |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_to_bytes : M.IsAssociatedFunction.C Self "to_bytes" to_bytes.
  Admitted.
  Global Typeclasses Opaque to_bytes.
  
  (*
      pub const fn as_array(&self) -> &[u8; 32] {
          &self.0
      }
  *)
  Definition as_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "solana_address::Address",
                0
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_array : M.IsAssociatedFunction.C Self "as_array" as_array.
  Admitted.
  Global Typeclasses Opaque as_array.
End Impl_solana_address_Address.

Module Impl_core_convert_AsRef_slice_u8_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*
      fn as_ref(&self) -> &[u8] {
          &self.0[..]
      }
  *)
  Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ],
                    [],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "solana_address::Address",
                        0
                      |)
                    |);
                    Value.StructTuple "core::ops::range::RangeFull" [] [] []
                  ]
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::AsRef"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
      Self
      (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
End Impl_core_convert_AsRef_slice_u8_for_solana_address_Address.

Module Impl_core_convert_AsMut_slice_u8_for_solana_address_Address.
  Definition Self : Ty.t := Ty.path "solana_address::Address".
  
  (*
      fn as_mut(&mut self) -> &mut [u8] {
          &mut self.0[..]
      }
  *)
  Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "solana_address::Address" ], self |) in
        M.borrow (|
          Pointer.Kind.MutRef,
          M.deref (|
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          [ Ty.path "u8" ],
                        [],
                        [ Ty.path "core::ops::range::RangeFull" ],
                        "index_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_address::Address",
                            0
                          |)
                        |);
                        Value.StructTuple "core::ops::range::RangeFull" [] [] []
                      ]
                    |)
                  |)
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::AsMut"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
      Self
      (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
End Impl_core_convert_AsMut_slice_u8_for_solana_address_Address.
