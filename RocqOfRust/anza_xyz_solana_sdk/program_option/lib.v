(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

(*
Enum COption
{
  const_params := [];
  ty_params := [ "T" ];
  variants :=
    [
      {
        name := "None";
        item := StructTuple [];
      };
      {
        name := "Some";
        item := StructTuple [ T ];
      }
    ];
}
*)

Axiom IsDiscriminant_COption_None : M.IsDiscriminant "solana_program_option::COption::None" 0.
Axiom IsDiscriminant_COption_Some : M.IsDiscriminant "solana_program_option::COption::Some" 1.

Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::marker::Copy"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [].
End Impl_core_marker_Copy_where_core_marker_Copy_T_for_solana_program_option_COption_T.

Module Impl_core_marker_StructuralPartialEq_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_solana_program_option_COption_T.

Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_solana_program_option_COption_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (* PartialEq *)
  Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let other :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            other
          |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |) in
          let~ __arg1_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
            |) in
          M.alloc (|
            Ty.path "bool",
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |),
              ltac:(M.monadic
                (M.match_operator (|
                  Ty.path "bool",
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
                      ],
                    Value.Tuple [ M.read (| self |); M.read (| other |) ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                        let γ2_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_0,
                            "solana_program_option::COption::Some",
                            0
                          |) in
                        let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                        let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                        let γ2_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_1,
                            "solana_program_option::COption::Some",
                            0
                          |) in
                        let __arg1_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_trait_method (|
                            "core::cmp::PartialEq",
                            Ty.apply (Ty.path "&") [] [ T ],
                            [],
                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                            "eq",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, __self_0 |);
                            M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (Value.Bool true))
                  ]
                |)))
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
      (Self T)
      (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_solana_program_option_COption_T_for_solana_program_option_COption_T.

Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_solana_program_option_COption_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (* PartialOrd *)
  Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let other :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            other
          |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |) in
          let~ __arg1_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
            |) in
          M.alloc (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ];
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
                  ],
                Value.Tuple [ M.read (| self |); M.read (| other |) ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "solana_program_option::COption::Some",
                        0
                      |) in
                    let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                    let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "solana_program_option::COption::Some",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::cmp::Ordering" ],
                      M.get_trait_method (|
                        "core::cmp::PartialOrd",
                        T,
                        [],
                        [ T ],
                        "partial_cmp",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::cmp::Ordering" ],
                      M.get_trait_method (|
                        "core::cmp::PartialOrd",
                        Ty.path "isize",
                        [],
                        [ Ty.path "isize" ],
                        "partial_cmp",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                        |)
                      ]
                    |)))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::cmp::PartialOrd"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
      (Self T)
      (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_solana_program_option_COption_T_for_solana_program_option_COption_T.

Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (* Eq *)
  Definition assert_receiver_is_total_eq
      (T : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.match_operator (|
          Ty.tuple [],
          Value.DeclaredButUndefined,
          [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *)
      [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_solana_program_option_COption_T.

Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (* Ord *)
  Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let other :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            other
          |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |) in
          let~ __arg1_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
            |) in
          M.alloc (|
            Ty.path "core::cmp::Ordering",
            M.match_operator (|
              Ty.path "core::cmp::Ordering",
              M.alloc (|
                Ty.path "core::cmp::Ordering",
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], [], "cmp", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.path "core::cmp::Ordering",
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
                          ],
                        Value.Tuple [ M.read (| self |); M.read (| other |) ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "solana_program_option::COption::Some",
                                0
                              |) in
                            let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                            let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "solana_program_option::COption::Some",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                            M.call_closure (|
                              Ty.path "core::cmp::Ordering",
                              M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| __self_0 |) |)
                                |);
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic (Value.StructTuple "core::cmp::Ordering::Equal" [] [] []))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| Ty.path "core::cmp::Ordering", γ |) in
                    M.read (| cmp |)))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::cmp::Ord"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
End Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_solana_program_option_COption_T.

Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (* Debug *)
  Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let f := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
        M.match_operator (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "write_str",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "None" |) |) |)
                  ]
                |)));
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_tuple_field1_finish",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Some" |) |) |);
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                      M.pointer_coercion
                        M.PointerCoercion.Unsize
                        (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ])
                        (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                        |)
                      ]
                    |)
                  ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_solana_program_option_COption_T.

Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (* Hash *)
  Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ __H ], [ self; state ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::discriminant_value",
                [],
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.path "isize",
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |) in
          M.alloc (|
            Ty.tuple [],
            M.match_operator (|
              Ty.tuple [],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "solana_program_option::COption::Some",
                        0
                      |) in
                    let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                      ]
                    |)));
                fun γ => ltac:(M.monadic (Value.Tuple []))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::hash::Hash"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
End Impl_core_hash_Hash_where_core_hash_Hash_T_for_solana_program_option_COption_T.

Module Impl_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (*
      pub fn is_some(&self) -> bool {
          match *self {
              COption::Some(_) => true,
              COption::None => false,
          }
      }
  *)
  Definition is_some (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.match_operator (|
          Ty.path "bool",
          M.deref (| M.read (| self |) |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                Value.Bool true));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.Bool false))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_is_some :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "is_some" (is_some T).
  Admitted.
  Global Typeclasses Opaque is_some.
  
  (*
      pub fn is_none(&self) -> bool {
          !self.is_some()
      }
  *)
  Definition is_none (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.path "bool",
          UnOp.not,
          [
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                "is_some",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_is_none :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "is_none" (is_none T).
  Admitted.
  Global Typeclasses Opaque is_none.
  
  (*
      pub fn contains<U>(&self, x: &U) -> bool
      where
          U: PartialEq<T>,
      {
          match self {
              COption::Some(y) => x == y,
              COption::None => false,
          }
      }
  *)
  Definition contains (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ U ], [ self; x ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let x := M.alloc (| Ty.apply (Ty.path "&") [] [ U ], x |) in
        M.match_operator (|
          Ty.path "bool",
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let y := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply (Ty.path "&") [] [ U ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                    "eq",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, x |); M.borrow (| Pointer.Kind.Ref, y |) ]
                |)));
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.Bool false))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_contains :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "contains" (contains T).
  Admitted.
  Global Typeclasses Opaque contains.
  
  (*
      pub fn as_ref(&self) -> COption<&T> {
          match *self {
              COption::Some(ref x) => COption::Some(x),
              COption::None => COption::None,
          }
      }
  *)
  Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.match_operator (|
          Ty.apply
            (Ty.path "solana_program_option::COption")
            []
            [ Ty.apply (Ty.path "&") [] [ T ] ],
          M.deref (| M.read (| self |) |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ0_0 |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ Ty.apply (Ty.path "&") [] [ T ] ]
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple
                  "solana_program_option::COption::None"
                  []
                  [ Ty.apply (Ty.path "&") [] [ T ] ]
                  []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_ref :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "as_ref" (as_ref T).
  Admitted.
  Global Typeclasses Opaque as_ref.
  
  (*
      pub fn as_mut(&mut self) -> COption<&mut T> {
          match *self {
              COption::Some(ref mut x) => COption::Some(x),
              COption::None => COption::None,
          }
      }
  *)
  Definition as_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.match_operator (|
          Ty.apply
            (Ty.path "solana_program_option::COption")
            []
            [ Ty.apply (Ty.path "&mut") [] [ T ] ],
          M.deref (| M.read (| self |) |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_0 |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple
                  "solana_program_option::COption::None"
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                  []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_mut :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "as_mut" (as_mut T).
  Admitted.
  Global Typeclasses Opaque as_mut.
  
  (*
      pub fn expect(self, msg: &str) -> T {
          match self {
              COption::Some(val) => val,
              COption::None => expect_failed(msg),
          }
      }
  *)
  Definition expect (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; msg ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let msg := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "str" ], msg |) in
        M.match_operator (|
          T,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let val := M.copy (| T, γ0_0 |) in
                M.read (| val |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.never_to_any (|
                  M.call_closure (|
                    Ty.path "never",
                    M.get_function (| "solana_program_option::expect_failed", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| msg |) |) |) ]
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_expect :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "expect" (expect T).
  Admitted.
  Global Typeclasses Opaque expect.
  
  (*
      pub fn unwrap(self) -> T {
          match self {
              COption::Some(val) => val,
              COption::None => panic!("called `COption::unwrap()` on a `COption::None` value"),
          }
      }
  *)
  Definition unwrap (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        M.match_operator (|
          T,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let val := M.copy (| T, γ0_0 |) in
                M.read (| val |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.never_to_any (|
                  M.call_closure (|
                    Ty.path "never",
                    M.get_function (| "core::panicking::panic_fmt", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "core::fmt::Arguments",
                        M.get_associated_function (|
                          Ty.path "core::fmt::Arguments",
                          "new_const",
                          [ Value.Integer IntegerKind.Usize 1 ],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 1 ]
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                  Value.Array
                                    [
                                      mk_str (|
                                        "called `COption::unwrap()` on a `COption::None` value"
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_unwrap :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "unwrap" (unwrap T).
  Admitted.
  Global Typeclasses Opaque unwrap.
  
  (*
      pub fn unwrap_or(self, def: T) -> T {
          match self {
              COption::Some(x) => x,
              COption::None => def,
          }
      }
  *)
  Definition unwrap_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; def ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let def := M.alloc (| T, def |) in
        M.match_operator (|
          T,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.copy (| T, γ0_0 |) in
                M.read (| x |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.read (| def |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_unwrap_or :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "unwrap_or" (unwrap_or T).
  Admitted.
  Global Typeclasses Opaque unwrap_or.
  
  (*
      pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {
          match self {
              COption::Some(x) => x,
              COption::None => f(),
          }
      }
  *)
  Definition unwrap_or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ F ], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let f := M.alloc (| F, f |) in
        M.match_operator (|
          T,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.copy (| T, γ0_0 |) in
                M.read (| x |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.call_closure (|
                  T,
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [] ],
                    "call_once",
                    [],
                    []
                  |),
                  [ M.read (| f |); Value.Tuple [] ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_unwrap_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "unwrap_or_else" (unwrap_or_else T).
  Admitted.
  Global Typeclasses Opaque unwrap_or_else.
  
  (*
      pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> COption<U> {
          match self {
              COption::Some(x) => COption::Some(f(x)),
              COption::None => COption::None,
          }
      }
  *)
  Definition map (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ U; F ], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let f := M.alloc (| F, f |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ U ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.copy (| T, γ0_0 |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ U ]
                  [
                    M.call_closure (|
                      U,
                      M.get_trait_method (|
                        "core::ops::function::FnOnce",
                        F,
                        [],
                        [ Ty.tuple [ T ] ],
                        "call_once",
                        [],
                        []
                      |),
                      [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                    |)
                  ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple "solana_program_option::COption::None" [] [ U ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_map :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "map" (map T).
  Admitted.
  Global Typeclasses Opaque map.
  
  (*
      pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {
          match self {
              COption::Some(t) => f(t),
              COption::None => default,
          }
      }
  *)
  Definition map_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ U; F ], [ self; default; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let default := M.alloc (| U, default |) in
        let f := M.alloc (| F, f |) in
        M.match_operator (|
          U,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let t := M.copy (| T, γ0_0 |) in
                M.call_closure (|
                  U,
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [ T ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [ M.read (| f |); Value.Tuple [ M.read (| t |) ] ]
                |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.read (| default |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_map_or :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "map_or" (map_or T).
  Admitted.
  Global Typeclasses Opaque map_or.
  
  (*
      pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {
          match self {
              COption::Some(t) => f(t),
              COption::None => default(),
          }
      }
  *)
  Definition map_or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ U; D; F ], [ self; default; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let default := M.alloc (| D, default |) in
        let f := M.alloc (| F, f |) in
        M.match_operator (|
          U,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let t := M.copy (| T, γ0_0 |) in
                M.call_closure (|
                  U,
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [ T ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [ M.read (| f |); Value.Tuple [ M.read (| t |) ] ]
                |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.call_closure (|
                  U,
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    D,
                    [],
                    [ Ty.tuple [] ],
                    "call_once",
                    [],
                    []
                  |),
                  [ M.read (| default |); Value.Tuple [] ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_map_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "map_or_else" (map_or_else T).
  Admitted.
  Global Typeclasses Opaque map_or_else.
  
  (*
      pub fn ok_or<E>(self, err: E) -> Result<T, E> {
          match self {
              COption::Some(v) => Ok(v),
              COption::None => Err(err),
          }
      }
  *)
  Definition ok_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ E ], [ self; err ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let err := M.alloc (| E, err |) in
        M.match_operator (|
          Ty.apply (Ty.path "core::result::Result") [] [ T; E ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let v := M.copy (| T, γ0_0 |) in
                Value.StructTuple "core::result::Result::Ok" [] [ T; E ] [ M.read (| v |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple "core::result::Result::Err" [] [ T; E ] [ M.read (| err |) ]))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_ok_or :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "ok_or" (ok_or T).
  Admitted.
  Global Typeclasses Opaque ok_or.
  
  (*
      pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {
          match self {
              COption::Some(v) => Ok(v),
              COption::None => Err(err()),
          }
      }
  *)
  Definition ok_or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ E; F ], [ self; err ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let err := M.alloc (| F, err |) in
        M.match_operator (|
          Ty.apply (Ty.path "core::result::Result") [] [ T; E ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let v := M.copy (| T, γ0_0 |) in
                Value.StructTuple "core::result::Result::Ok" [] [ T; E ] [ M.read (| v |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple
                  "core::result::Result::Err"
                  []
                  [ T; E ]
                  [
                    M.call_closure (|
                      E,
                      M.get_trait_method (|
                        "core::ops::function::FnOnce",
                        F,
                        [],
                        [ Ty.tuple [] ],
                        "call_once",
                        [],
                        []
                      |),
                      [ M.read (| err |); Value.Tuple [] ]
                    |)
                  ]))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_ok_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "ok_or_else" (ok_or_else T).
  Admitted.
  Global Typeclasses Opaque ok_or_else.
  
  (*
      pub fn and<U>(self, optb: COption<U>) -> COption<U> {
          match self {
              COption::Some(_) => optb,
              COption::None => COption::None,
          }
      }
  *)
  Definition and (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ U ], [ self; optb ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let optb :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ U ], optb |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ U ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                M.read (| optb |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple "solana_program_option::COption::None" [] [ U ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_and :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "and" (and T).
  Admitted.
  Global Typeclasses Opaque and.
  
  (*
      pub fn and_then<U, F: FnOnce(T) -> COption<U>>(self, f: F) -> COption<U> {
          match self {
              COption::Some(x) => f(x),
              COption::None => COption::None,
          }
      }
  *)
  Definition and_then (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ U; F ], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let f := M.alloc (| F, f |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ U ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.copy (| T, γ0_0 |) in
                M.call_closure (|
                  Ty.apply (Ty.path "solana_program_option::COption") [] [ U ],
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [ T ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [ M.read (| f |); Value.Tuple [ M.read (| x |) ] ]
                |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple "solana_program_option::COption::None" [] [ U ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_and_then :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "and_then" (and_then T).
  Admitted.
  Global Typeclasses Opaque and_then.
  
  (*
      pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {
          if let COption::Some(x) = self {
              if predicate(&x) {
                  return COption::Some(x);
              }
          }
          COption::None
      }
  *)
  Definition filter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ P ], [ self; predicate ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let predicate := M.alloc (| P, predicate |) in
        M.catch_return (Ty.apply (Ty.path "solana_program_option::COption") [] [ T ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := self in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "solana_program_option::COption::Some",
                            0
                          |) in
                        let x := M.copy (| T, γ0_0 |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::ops::function::FnOnce",
                                          P,
                                          [],
                                          [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                          "call_once",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| predicate |);
                                          Value.Tuple
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, x |) |)
                                              |)
                                            ]
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "solana_program_option::COption::Some"
                                        []
                                        [ T ]
                                        [ M.read (| x |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (Value.Tuple []))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                Value.StructTuple "solana_program_option::COption::None" [] [ T ] []
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_filter :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "filter" (filter T).
  Admitted.
  Global Typeclasses Opaque filter.
  
  (*
      pub fn or(self, optb: COption<T>) -> COption<T> {
          match self {
              COption::Some(_) => self,
              COption::None => optb,
          }
      }
  *)
  Definition or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; optb ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let optb :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], optb |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                M.read (| self |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.read (| optb |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_or :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "or" (or T).
  Admitted.
  Global Typeclasses Opaque or.
  
  (*
      pub fn or_else<F: FnOnce() -> COption<T>>(self, f: F) -> COption<T> {
          match self {
              COption::Some(_) => self,
              COption::None => f(),
          }
      }
  *)
  Definition or_else (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ F ], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let f := M.alloc (| F, f |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                M.read (| self |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.call_closure (|
                  Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [] ],
                    "call_once",
                    [],
                    []
                  |),
                  [ M.read (| f |); Value.Tuple [] ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "or_else" (or_else T).
  Admitted.
  Global Typeclasses Opaque or_else.
  
  (*
      pub fn xor(self, optb: COption<T>) -> COption<T> {
          match (self, optb) {
              (COption::Some(a), COption::None) => COption::Some(a),
              (COption::None, COption::Some(b)) => COption::Some(b),
              _ => COption::None,
          }
      }
  *)
  Definition xor (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; optb ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        let optb :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], optb |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "solana_program_option::COption") [] [ T ];
                Ty.apply (Ty.path "solana_program_option::COption") [] [ T ]
              ],
            Value.Tuple [ M.read (| self |); M.read (| optb |) ]
          |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ0_0,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let a := M.copy (| T, γ1_0 |) in
                let _ := M.is_struct_tuple (| γ0_1, "solana_program_option::COption::None" |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ T ]
                  [ M.read (| a |) ]));
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let _ := M.is_struct_tuple (| γ0_0, "solana_program_option::COption::None" |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ0_1,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let b := M.copy (| T, γ1_0 |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ T ]
                  [ M.read (| b |) ]));
            fun γ =>
              ltac:(M.monadic
                (Value.StructTuple "solana_program_option::COption::None" [] [ T ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_xor :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "xor" (xor T).
  Admitted.
  Global Typeclasses Opaque xor.
  
  (*
      pub fn get_or_insert(&mut self, v: T) -> &mut T {
          self.get_or_insert_with(|| v)
      }
  *)
  Definition get_or_insert (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; v ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let v := M.alloc (| T, v |) in
        M.borrow (|
          Pointer.Kind.MutRef,
          M.deref (|
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&mut") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                    "get_or_insert_with",
                    [],
                    [ Ty.function [] T ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                T,
                                M.alloc (| Ty.tuple [], α0 |),
                                [ fun γ => ltac:(M.monadic (M.read (| v |))) ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_get_or_insert :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "get_or_insert" (get_or_insert T).
  Admitted.
  Global Typeclasses Opaque get_or_insert.
  
  (*
      pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {
          if let COption::None = *self {
              *self = COption::Some(f())
          }
  
          match *self {
              COption::Some(ref mut v) => v,
              COption::None => unreachable!(),
          }
      }
  *)
  Definition get_or_insert_with
      (T : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [ F ], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let f := M.alloc (| F, f |) in
        M.borrow (|
          Pointer.Kind.MutRef,
          M.deref (|
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.deref (| M.read (| self |) |) in
                        let _ :=
                          M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                        M.write (|
                          M.deref (| M.read (| self |) |),
                          Value.StructTuple
                            "solana_program_option::COption::Some"
                            []
                            [ T ]
                            [
                              M.call_closure (|
                                T,
                                M.get_trait_method (|
                                  "core::ops::function::FnOnce",
                                  F,
                                  [],
                                  [ Ty.tuple [] ],
                                  "call_once",
                                  [],
                                  []
                                |),
                                [ M.read (| f |); Value.Tuple [] ]
                              |)
                            ]
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ T ],
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.match_operator (|
                      Ty.apply (Ty.path "&mut") [] [ T ],
                      M.deref (| M.read (| self |) |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "solana_program_option::COption::Some",
                                0
                              |) in
                            let v := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_0 |) in
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| v |) |) |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic", [], [] |),
                                [ mk_str (| "internal error: entered unreachable code" |) ]
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_get_or_insert_with :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "get_or_insert_with" (get_or_insert_with T).
  Admitted.
  Global Typeclasses Opaque get_or_insert_with.
  
  (*
      pub fn replace(&mut self, value: T) -> COption<T> {
          mem::replace(self, COption::Some(value))
      }
  *)
  Definition replace (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; value ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let value := M.alloc (| T, value |) in
        M.call_closure (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.get_function (|
            "core::mem::replace",
            [],
            [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
          |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
            Value.StructTuple "solana_program_option::COption::Some" [] [ T ] [ M.read (| value |) ]
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_replace :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "replace" (replace T).
  Admitted.
  Global Typeclasses Opaque replace.
  (*
      pub fn unwrap_or_default(self) -> T {
          match self {
              COption::Some(x) => x,
              COption::None => T::default(),
          }
      }
  *)
  Definition unwrap_or_default
      (T : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], self |) in
        M.match_operator (|
          T,
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.copy (| T, γ0_0 |) in
                M.read (| x |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_unwrap_or_default :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "unwrap_or_default" (unwrap_or_default T).
  Admitted.
  Global Typeclasses Opaque unwrap_or_default.
  (*
      pub fn as_deref(&self) -> COption<&T::Target> {
          self.as_ref().map(|t| t.deref())
      }
  *)
  Definition as_deref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "solana_program_option::COption")
            []
            [
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ]
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&") [] [ T ] ],
            "map",
            [],
            [
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ];
              Ty.function
                [ Ty.apply (Ty.path "&") [] [ T ] ]
                (Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ])
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "solana_program_option::COption")
                []
                [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                "as_ref",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ],
                        M.alloc (| Ty.apply (Ty.path "&") [] [ T ], α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let t := M.copy (| Ty.apply (Ty.path "&") [] [ T ], γ |) in
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "core::ops::deref::Deref"
                                      []
                                      []
                                      T
                                      "Target"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  T,
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| t |) |) |) ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_deref :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "as_deref" (as_deref T).
  Admitted.
  Global Typeclasses Opaque as_deref.
  (*
      pub fn as_deref_mut(&mut self) -> COption<&mut T::Target> {
          self.as_mut().map(|t| t.deref_mut())
      }
  *)
  Definition as_deref_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "solana_program_option::COption")
            []
            [
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ]
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            "map",
            [],
            [
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ];
              Ty.function
                [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                (Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ])
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "solana_program_option::COption")
                []
                [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                "as_mut",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.associated_in_trait "core::ops::deref::Deref" [] [] T "Target" ],
                        M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let t := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ |) in
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "core::ops::deref::Deref"
                                      []
                                      []
                                      T
                                      "Target"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  T,
                                  [],
                                  [],
                                  "deref_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| t |) |) |) ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_deref_mut :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "as_deref_mut" (as_deref_mut T).
  Admitted.
  Global Typeclasses Opaque as_deref_mut.
End Impl_solana_program_option_COption_T.

Module Impl_solana_program_option_COption_ref__T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "solana_program_option::COption") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
  
  (*
      pub fn copied(self) -> COption<T> {
          self.map(|&t| t)
      }
  *)
  Definition copied (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&") [] [ T ] ],
            "map",
            [],
            [ T; Ty.function [ Ty.apply (Ty.path "&") [] [ T ] ] T ]
          |),
          [
            M.read (| self |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        T,
                        M.alloc (| Ty.apply (Ty.path "&") [] [ T ], α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.deref (| M.read (| γ |) |) in
                              let t := M.copy (| T, γ |) in
                              M.read (| t |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_copied :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "copied" (copied T).
  Admitted.
  Global Typeclasses Opaque copied.
  (*
      pub fn cloned(self) -> COption<T> {
          self.map(|t| t.clone())
      }
  *)
  Definition cloned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&") [] [ T ] ],
            "map",
            [],
            [ T; Ty.function [ Ty.apply (Ty.path "&") [] [ T ] ] T ]
          |),
          [
            M.read (| self |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        T,
                        M.alloc (| Ty.apply (Ty.path "&") [] [ T ], α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let t := M.copy (| Ty.apply (Ty.path "&") [] [ T ], γ |) in
                              M.call_closure (|
                                T,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  T,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| t |) |) |) ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_cloned :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "cloned" (cloned T).
  Admitted.
  Global Typeclasses Opaque cloned.
End Impl_solana_program_option_COption_ref__T.

Module Impl_solana_program_option_COption_ref_mut_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "solana_program_option::COption") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ].
  
  (*
      pub fn copied(self) -> COption<T> {
          self.map(|&mut t| t)
      }
  *)
  Definition copied (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            "map",
            [],
            [ T; Ty.function [ Ty.apply (Ty.path "&mut") [] [ T ] ] T ]
          |),
          [
            M.read (| self |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        T,
                        M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.deref (| M.read (| γ |) |) in
                              let t := M.copy (| T, γ |) in
                              M.read (| t |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_copied :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "copied" (copied T).
  Admitted.
  Global Typeclasses Opaque copied.
  (*
      pub fn cloned(self) -> COption<T> {
          self.map(|t| t.clone())
      }
  *)
  Definition cloned (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
            "map",
            [],
            [ T; Ty.function [ Ty.apply (Ty.path "&mut") [] [ T ] ] T ]
          |),
          [
            M.read (| self |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        T,
                        M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let t := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ |) in
                              M.call_closure (|
                                T,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  T,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| t |) |) |) ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_cloned :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "cloned" (cloned T).
  Admitted.
  Global Typeclasses Opaque cloned.
End Impl_solana_program_option_COption_ref_mut_T.






Module Impl_solana_program_option_COption_core_result_Result_T_E.
  Definition Self (T E : Ty.t) : Ty.t :=
    Ty.apply
      (Ty.path "solana_program_option::COption")
      []
      [ Ty.apply (Ty.path "core::result::Result") [] [ T; E ] ].
  
  (*
      pub fn transpose(self) -> Result<COption<T>, E> {
          match self {
              COption::Some(Ok(x)) => Ok(COption::Some(x)),
              COption::Some(Err(e)) => Err(e),
              COption::None => Ok(COption::None),
          }
      }
  *)
  Definition transpose (T E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T E in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "core::result::Result") [] [ T; E ] ],
            self
          |) in
        M.match_operator (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ]; E ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (| γ0_0, "core::result::Result::Ok", 0 |) in
                let x := M.copy (| T, γ1_0 |) in
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ]; E ]
                  [
                    Value.StructTuple
                      "solana_program_option::COption::Some"
                      []
                      [ T ]
                      [ M.read (| x |) ]
                  ]));
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (| γ0_0, "core::result::Result::Err", 0 |) in
                let e := M.copy (| E, γ1_0 |) in
                Value.StructTuple
                  "core::result::Result::Err"
                  []
                  [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ]; E ]
                  [ M.read (| e |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ]; E ]
                  [ Value.StructTuple "solana_program_option::COption::None" [] [ T ] [] ]))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_transpose :
    forall (T E : Ty.t),
    M.IsAssociatedFunction.C (Self T E) "transpose" (transpose T E).
  Admitted.
  Global Typeclasses Opaque transpose.
End Impl_solana_program_option_COption_core_result_Result_T_E.

(*
fn expect_failed(msg: &str) -> ! {
    panic!("{}", msg)
}
*)
Definition expect_failed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ msg ] =>
    ltac:(M.monadic
      (let msg := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "str" ], msg |) in
      M.call_closure (|
        Ty.path "never",
        M.get_function (| "solana_program_option::expect_failed.panic_cold_display", [], [] |),
        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, msg |) |) |) ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_expect_failed :
  M.IsFunction.C "solana_program_option::expect_failed" expect_failed.
Admitted.
Global Typeclasses Opaque expect_failed.

Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (*
      fn clone(&self) -> Self {
          match self {
              COption::Some(x) => COption::Some(x.clone()),
              COption::None => COption::None,
          }
      }
  *)
  Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let γ1_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let x := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_0 |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ T ]
                  [
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                    |)
                  ]));
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple "solana_program_option::COption::None" [] [ T ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      fn clone_from(&mut self, source: &Self) {
          match (self, source) {
              (COption::Some(to), COption::Some(from)) => to.clone_from(from),
              (to, from) => to.clone_from(from),
          }
      }
  *)
  Definition clone_from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self; source ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        let source :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            source
          |) in
        M.match_operator (|
          Ty.tuple [],
          M.alloc (|
            Ty.tuple
              [
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ];
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
              ],
            Value.Tuple [ M.read (| self |); M.read (| source |) ]
          |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                let γ2_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ0_0,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let to := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], γ2_0 |) in
                let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                let γ2_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ0_1,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let from := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_0 |) in
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::clone::Clone", T, [], [], "clone_from", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| to |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| from |) |) |)
                  ]
                |)));
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let to :=
                  M.copy (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
                    γ0_0
                  |) in
                let from :=
                  M.copy (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
                    γ0_1
                  |) in
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
                    [],
                    [],
                    "clone_from",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| to |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| from |) |) |)
                  ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *)
      [
        ("clone", InstanceField.Method (clone T));
        ("clone_from", InstanceField.Method (clone_from T))
      ].
End Impl_core_clone_Clone_where_core_clone_Clone_T_for_solana_program_option_COption_T.

Module Impl_core_default_Default_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (*
      fn default() -> COption<T> {
          COption::None
      }
  *)
  Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic (Value.StructTuple "solana_program_option::COption::None" [] [ T ] []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::default::Default"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("default", InstanceField.Method (default T)) ].
End Impl_core_default_Default_for_solana_program_option_COption_T.

Module Impl_core_convert_From_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (*
      fn from(val: T) -> COption<T> {
          COption::Some(val)
      }
  *)
  Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ val ] =>
      ltac:(M.monadic
        (let val := M.alloc (| T, val |) in
        Value.StructTuple "solana_program_option::COption::Some" [] [ T ] [ M.read (| val |) ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ T ]
      (Self T)
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_T_for_solana_program_option_COption_T.

Module Impl_core_convert_From_ref__solana_program_option_COption_T_for_solana_program_option_COption_ref__T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "solana_program_option::COption") [] [ Ty.apply (Ty.path "&") [] [ T ] ].
  
  (*
      fn from(o: &'a COption<T>) -> COption<&'a T> {
          o.as_ref()
      }
  *)
  Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ o ] =>
      ltac:(M.monadic
        (let o :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            o
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "solana_program_option::COption")
            []
            [ Ty.apply (Ty.path "&") [] [ T ] ],
          M.get_associated_function (|
            Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
            "as_ref",
            [],
            []
          |),
          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| o |) |) |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *)
      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ] ]
      (Self T)
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_ref__solana_program_option_COption_T_for_solana_program_option_COption_ref__T.

Module Impl_core_convert_From_ref_mut_solana_program_option_COption_T_for_solana_program_option_COption_ref_mut_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "solana_program_option::COption") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ].
  
  (*
      fn from(o: &'a mut COption<T>) -> COption<&'a mut T> {
          o.as_mut()
      }
  *)
  Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ o ] =>
      ltac:(M.monadic
        (let o :=
          M.alloc (|
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            o
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "solana_program_option::COption")
            []
            [ Ty.apply (Ty.path "&mut") [] [ T ] ],
          M.get_associated_function (|
            Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
            "as_mut",
            [],
            []
          |),
          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| o |) |) |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *)
      [
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
      ]
      (Self T)
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_ref_mut_solana_program_option_COption_T_for_solana_program_option_COption_ref_mut_T.

Module Impl_solana_program_option_COption_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply
      (Ty.path "solana_program_option::COption")
      []
      [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ].
  
  (*
      pub fn flatten(self) -> COption<T> {
          self.and_then(convert::identity)
      }
  *)
  Definition flatten (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            self
          |) in
        M.call_closure (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "solana_program_option::COption")
              []
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ],
            "and_then",
            [],
            [
              T;
              Ty.function
                [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
                (Ty.apply (Ty.path "solana_program_option::COption") [] [ T ])
            ]
          |),
          [
            M.read (| self |);
            M.get_function (|
              "core::convert::identity",
              [],
              [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_flatten :
    forall (T : Ty.t),
    M.IsAssociatedFunction.C (Self T) "flatten" (flatten T).
  Admitted.
  Global Typeclasses Opaque flatten.
End Impl_solana_program_option_COption_solana_program_option_COption_T.

Module Impl_core_convert_From_core_option_Option_T_for_solana_program_option_COption_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "solana_program_option::COption") [] [ T ].
  
  (*
      fn from(option: Option<T>) -> Self {
          match option {
              Some(value) => COption::Some(value),
              None => COption::None,
          }
      }
  *)
  Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ option ] =>
      ltac:(M.monadic
        (let option := M.alloc (| Ty.apply (Ty.path "core::option::Option") [] [ T ], option |) in
        M.match_operator (|
          Ty.apply (Ty.path "solana_program_option::COption") [] [ T ],
          option,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                let value := M.copy (| T, γ0_0 |) in
                Value.StructTuple
                  "solana_program_option::COption::Some"
                  []
                  [ T ]
                  [ M.read (| value |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                Value.StructTuple "solana_program_option::COption::None" [] [ T ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "core::option::Option") [] [ T ] ]
      (Self T)
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_core_option_Option_T_for_solana_program_option_COption_T.

Module Impl_core_convert_From_solana_program_option_COption_T_for_core_option_Option_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [] [ T ].
  
  (*
      fn from(coption: COption<T>) -> Self {
          match coption {
              COption::Some(value) => Some(value),
              COption::None => None,
          }
      }
  *)
  Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ coption ] =>
      ltac:(M.monadic
        (let coption :=
          M.alloc (| Ty.apply (Ty.path "solana_program_option::COption") [] [ T ], coption |) in
        M.match_operator (|
          Ty.apply (Ty.path "core::option::Option") [] [ T ],
          coption,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 :=
                  M.SubPointer.get_struct_tuple_field (|
                    γ,
                    "solana_program_option::COption::Some",
                    0
                  |) in
                let value := M.copy (| T, γ0_0 |) in
                Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| value |) ]));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "solana_program_option::COption::None" |) in
                Value.StructTuple "core::option::Option::None" [] [ T ] []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "solana_program_option::COption") [] [ T ] ]
      (Self T)
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_solana_program_option_COption_T_for_core_option_Option_T.
