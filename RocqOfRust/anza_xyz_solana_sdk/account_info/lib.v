(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

Definition value_MAX_PERMITTED_DATA_INCREASE
    (ε : list Value.t)
    (τ : list Ty.t)
    (α : list Value.t)
    : M :=
  ltac:(M.monadic
    (M.alloc (|
      Ty.path "usize",
      M.call_closure (|
        Ty.path "usize",
        BinOp.Wrap.mul,
        [ Value.Integer IntegerKind.Usize 1024; Value.Integer IntegerKind.Usize 10 ]
      |)
    |))).

Global Instance Instance_IsConstant_value_MAX_PERMITTED_DATA_INCREASE :
  M.IsFunction.C
    "solana_account_info::MAX_PERMITTED_DATA_INCREASE"
    value_MAX_PERMITTED_DATA_INCREASE.
Admitted.
Global Typeclasses Opaque value_MAX_PERMITTED_DATA_INCREASE.

(* StructRecord
  {
    name := "AccountInfo";
    const_params := [];
    ty_params := [];
    fields :=
      [
        ("key", Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ]);
        ("lamports",
          Ty.apply
            (Ty.path "alloc::rc::Rc")
            []
            [
              Ty.apply
                (Ty.path "core::cell::RefCell")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
              Ty.path "alloc::alloc::Global"
            ]);
        ("data",
          Ty.apply
            (Ty.path "alloc::rc::Rc")
            []
            [
              Ty.apply
                (Ty.path "core::cell::RefCell")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ];
              Ty.path "alloc::alloc::Global"
            ]);
        ("owner", Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ]);
        ("_unused", Ty.path "u64");
        ("is_signer", Ty.path "bool");
        ("is_writable", Ty.path "bool");
        ("executable", Ty.path "bool")
      ];
  } *)

Module Impl_core_clone_Clone_for_solana_account_info_AccountInfo.
  Definition Self : Ty.t := Ty.path "solana_account_info::AccountInfo".
  
  (* Clone *)
  Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        Value.mkStructRecord
          "solana_account_info::AccountInfo"
          []
          []
          [
            ("key",
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "solana_account_info::AccountInfo",
                              "key"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |));
            ("lamports",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::cell::RefCell")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "solana_account_info::AccountInfo",
                          "lamports"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("data",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::cell::RefCell")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "solana_account_info::AccountInfo",
                          "data"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("owner",
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "solana_account_info::AccountInfo",
                              "owner"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |));
            ("_unused",
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "u64",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "solana_account_info::AccountInfo",
                          "_unused"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("is_signer",
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "bool",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "solana_account_info::AccountInfo",
                          "is_signer"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("is_writable",
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "bool",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "solana_account_info::AccountInfo",
                          "is_writable"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("executable",
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "bool",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "solana_account_info::AccountInfo",
                          "executable"
                        |)
                      |)
                    |)
                  |)
                ]
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_solana_account_info_AccountInfo.

Module Impl_core_fmt_Debug_for_solana_account_info_AccountInfo.
  Definition Self : Ty.t := Ty.path "solana_account_info::AccountInfo".
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          let mut f = f.debug_struct("AccountInfo");
  
          f.field("key", &self.key)
              .field("owner", &self.owner)
              .field("is_signer", &self.is_signer)
              .field("is_writable", &self.is_writable)
              .field("executable", &self.executable)
              .field("lamports", &self.lamports())
              .field("data.len", &self.data_len());
          debug_account_data::debug_account_data(&self.data.borrow(), &mut f);
  
          f.finish_non_exhaustive()
      }
  *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        let f := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
        M.read (|
          let~ f : Ty.path "core::fmt::builders::DebugStruct" :=
            M.call_closure (|
              Ty.path "core::fmt::builders::DebugStruct",
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "AccountInfo" |) |) |)
              ]
            |) in
          let~ _ : Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ] :=
            M.call_closure (|
              Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "field",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.path "core::fmt::builders::DebugStruct" ],
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::builders::DebugStruct",
                                        "field",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::builders::DebugStruct",
                                                "field",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        []
                                                        [ Ty.path "core::fmt::builders::DebugStruct"
                                                        ],
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::builders::DebugStruct",
                                                        "field",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&mut")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "core::fmt::builders::DebugStruct"
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "core::fmt::builders::DebugStruct",
                                                                "field",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.MutRef,
                                                                  f
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| mk_str (| "key" |) |)
                                                                |);
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.dyn
                                                                        [
                                                                          ("core::fmt::Debug::Trait",
                                                                            [])
                                                                        ]
                                                                    ],
                                                                  M.pointer_coercion
                                                                    M.PointerCoercion.Unsize
                                                                    (Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "solana_address::Address"
                                                                          ]
                                                                      ])
                                                                    (Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [
                                                                        Ty.dyn
                                                                          [
                                                                            ("core::fmt::Debug::Trait",
                                                                              [])
                                                                          ]
                                                                      ]),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.SubPointer.get_struct_record_field (|
                                                                            M.deref (|
                                                                              M.read (| self |)
                                                                            |),
                                                                            "solana_account_info::AccountInfo",
                                                                            "key"
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "owner" |) |)
                                                        |);
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [
                                                              Ty.dyn
                                                                [ ("core::fmt::Debug::Trait", []) ]
                                                            ],
                                                          M.pointer_coercion
                                                            M.PointerCoercion.Unsize
                                                            (Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "solana_address::Address"
                                                                  ]
                                                              ])
                                                            (Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.dyn
                                                                  [ ("core::fmt::Debug::Trait", [])
                                                                  ]
                                                              ]),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "solana_account_info::AccountInfo",
                                                                    "owner"
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| mk_str (| "is_signer" |) |)
                                                |);
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                                  M.pointer_coercion
                                                    M.PointerCoercion.Unsize
                                                    (Ty.apply (Ty.path "&") [] [ Ty.path "bool" ])
                                                    (Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ]
                                                      ]),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "solana_account_info::AccountInfo",
                                                            "is_signer"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "is_writable" |) |)
                                        |);
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                          M.pointer_coercion
                                            M.PointerCoercion.Unsize
                                            (Ty.apply (Ty.path "&") [] [ Ty.path "bool" ])
                                            (Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "solana_account_info::AccountInfo",
                                                    "is_writable"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| mk_str (| "executable" |) |)
                                |);
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                  M.pointer_coercion
                                    M.PointerCoercion.Unsize
                                    (Ty.apply (Ty.path "&") [] [ Ty.path "bool" ])
                                    (Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "solana_account_info::AccountInfo",
                                            "executable"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "lamports" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u64" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.path "u64",
                                    M.call_closure (|
                                      Ty.path "u64",
                                      M.get_associated_function (|
                                        Ty.path "solana_account_info::AccountInfo",
                                        "lamports",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "data.len" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.path "solana_account_info::AccountInfo",
                                "data_len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_function (|
                "solana_account_info::debug_account_data::debug_account_data",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::cell::Ref")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::cell::Ref")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::cell::Ref")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::cell::RefCell")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ],
                                        "borrow",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::cell::RefCell")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [ Ty.path "u8" ]
                                                        ]
                                                    ]
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::cell::RefCell")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&mut")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ]
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "solana_account_info::AccountInfo",
                                                    "data"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.borrow (| Pointer.Kind.MutRef, f |) |)
                |)
              ]
            |) in
          M.alloc (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish_non_exhaustive",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, f |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_solana_account_info_AccountInfo.

Module Impl_solana_account_info_AccountInfo.
  Definition Self : Ty.t := Ty.path "solana_account_info::AccountInfo".
  
  (*
      pub fn signer_key(&self) -> Option<&Pubkey> {
          if self.is_signer {
              Some(self.key)
          } else {
              None
          }
      }
  *)
  Definition signer_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.match_operator (|
          Ty.apply
            (Ty.path "core::option::Option")
            []
            [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ],
          M.alloc (| Ty.tuple [], Value.Tuple [] |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ :=
                  M.use
                    (M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "solana_account_info::AccountInfo",
                      "is_signer"
                    |)) in
                let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                Value.StructTuple
                  "core::option::Option::Some"
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ]
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_account_info::AccountInfo",
                            "key"
                          |)
                        |)
                      |)
                    |)
                  ]));
            fun γ =>
              ltac:(M.monadic
                (Value.StructTuple
                  "core::option::Option::None"
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ]
                  []))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_signer_key :
    M.IsAssociatedFunction.C Self "signer_key" signer_key.
  Admitted.
  Global Typeclasses Opaque signer_key.
  
  (*
      pub fn unsigned_key(&self) -> &Pubkey {
          self.key
      }
  *)
  Definition unsigned_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "solana_account_info::AccountInfo",
                "key"
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_unsigned_key :
    M.IsAssociatedFunction.C Self "unsigned_key" unsigned_key.
  Admitted.
  Global Typeclasses Opaque unsigned_key.
  
  (*
      pub fn lamports(&self) -> u64 {
          **self.lamports.borrow()
      }
  *)
  Definition lamports (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.read (|
          M.deref (|
            M.read (|
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply
                      (Ty.path "core::cell::Ref")
                      []
                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                    [],
                    [],
                    "deref",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::cell::Ref")
                          []
                          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::cell::Ref")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::cell::RefCell")
                              []
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                            "borrow",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::cell::RefCell")
                                        []
                                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::cell::RefCell")
                                          []
                                          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "solana_account_info::AccountInfo",
                                        "lamports"
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_lamports : M.IsAssociatedFunction.C Self "lamports" lamports.
  Admitted.
  Global Typeclasses Opaque lamports.
  
  (*
      pub fn try_lamports(&self) -> Result<u64, ProgramError> {
          Ok( **self.try_borrow_lamports()?)
      }
  *)
  Definition try_lamports (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.path "u64"; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (Value.StructTuple
              "core::result::Result::Ok"
              []
              [ Ty.path "u64"; Ty.path "solana_program_error::ProgramError" ]
              [
                M.read (|
                  M.deref (|
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::cell::Ref")
                              []
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::cell::Ref")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                M.match_operator (|
                                  Ty.apply
                                    (Ty.path "core::cell::Ref")
                                    []
                                    [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::ops::control_flow::ControlFlow")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "solana_program_error::ProgramError"
                                          ];
                                        Ty.apply
                                          (Ty.path "core::cell::Ref")
                                          []
                                          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "solana_program_error::ProgramError"
                                            ];
                                          Ty.apply
                                            (Ty.path "core::cell::Ref")
                                            []
                                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::cell::Ref")
                                              []
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                                            Ty.path "solana_program_error::ProgramError"
                                          ],
                                        [],
                                        [],
                                        "branch",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::cell::Ref")
                                                []
                                                [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                                              Ty.path "solana_program_error::ProgramError"
                                            ],
                                          M.get_associated_function (|
                                            Ty.path "solana_account_info::AccountInfo",
                                            "try_borrow_lamports",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "solana_program_error::ProgramError"
                                              ],
                                            γ0_0
                                          |) in
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "u64";
                                                    Ty.path "solana_program_error::ProgramError"
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.path "u64";
                                                      Ty.path "solana_program_error::ProgramError"
                                                    ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.path "solana_program_error::ProgramError"
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path "core::cell::Ref")
                                              []
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                            γ0_0
                                          |) in
                                        M.read (| val |)))
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_lamports :
    M.IsAssociatedFunction.C Self "try_lamports" try_lamports.
  Admitted.
  Global Typeclasses Opaque try_lamports.
  
  (*
      pub unsafe fn original_data_len(&self) -> usize {
          let key_ptr = self.key as *const _ as *const u8;
          let original_data_len_ptr = key_ptr.offset(-4) as *const u32;
          *original_data_len_ptr as usize
      }
  *)
  Definition original_data_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.read (|
          let~ key_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
            M.cast
              (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
              (M.read (|
                M.use
                  (M.alloc (|
                    Ty.apply (Ty.path "*const") [] [ Ty.path "solana_address::Address" ],
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_account_info::AccountInfo",
                            "key"
                          |)
                        |)
                      |)
                    |)
                  |))
              |)) in
          let~ original_data_len_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u32" ] :=
            M.cast
              (Ty.apply (Ty.path "*const") [] [ Ty.path "u32" ])
              (M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                  "offset",
                  [],
                  []
                |),
                [ M.read (| key_ptr |); Value.Integer IntegerKind.Isize (-4) ]
              |)) in
          M.alloc (|
            Ty.path "usize",
            M.cast (Ty.path "usize") (M.read (| M.deref (| M.read (| original_data_len_ptr |) |) |))
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_original_data_len :
    M.IsAssociatedFunction.C Self "original_data_len" original_data_len.
  Admitted.
  Global Typeclasses Opaque original_data_len.
  
  (*
      pub fn data_len(&self) -> usize {
          self.data.borrow().len()
      }
  *)
  Definition data_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_associated_function (|
            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
            "len",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.read (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "core::cell::Ref")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "core::cell::Ref")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::cell::Ref")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::cell::RefCell")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                "borrow",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::cell::RefCell")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloc::rc::Rc")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::cell::RefCell")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "solana_account_info::AccountInfo",
                                            "data"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_data_len : M.IsAssociatedFunction.C Self "data_len" data_len.
  Admitted.
  Global Typeclasses Opaque data_len.
  
  (*
      pub fn try_data_len(&self) -> Result<usize, ProgramError> {
          Ok(self.try_borrow_data()?.len())
      }
  *)
  Definition try_data_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.path "usize"; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (Value.StructTuple
              "core::result::Result::Ok"
              []
              [ Ty.path "usize"; Ty.path "solana_program_error::ProgramError" ]
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "len",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.read (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::cell::Ref")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::cell::Ref")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                      ],
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "core::cell::Ref")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                        ],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::ops::control_flow::ControlFlow")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "solana_program_error::ProgramError"
                                              ];
                                            Ty.apply
                                              (Ty.path "core::cell::Ref")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ]
                                          ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "solana_program_error::ProgramError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::cell::Ref")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::cell::Ref")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ];
                                                Ty.path "solana_program_error::ProgramError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::cell::Ref")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [ Ty.path "u8" ]
                                                        ]
                                                    ];
                                                  Ty.path "solana_program_error::ProgramError"
                                                ],
                                              M.get_associated_function (|
                                                Ty.path "solana_account_info::AccountInfo",
                                                "try_borrow_data",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual :=
                                              M.copy (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "solana_program_error::ProgramError"
                                                  ],
                                                γ0_0
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.path "usize";
                                                        Ty.path "solana_program_error::ProgramError"
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.path "usize";
                                                          Ty.path
                                                            "solana_program_error::ProgramError"
                                                        ],
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path
                                                              "solana_program_error::ProgramError"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val :=
                                              M.copy (|
                                                Ty.apply
                                                  (Ty.path "core::cell::Ref")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ],
                                                γ0_0
                                              |) in
                                            M.read (| val |)))
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_data_len :
    M.IsAssociatedFunction.C Self "try_data_len" try_data_len.
  Admitted.
  Global Typeclasses Opaque try_data_len.
  
  (*
      pub fn data_is_empty(&self) -> bool {
          self.data.borrow().is_empty()
      }
  *)
  Definition data_is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_associated_function (|
            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
            "is_empty",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.read (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "core::cell::Ref")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "core::cell::Ref")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::cell::Ref")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::cell::RefCell")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                "borrow",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::cell::RefCell")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloc::rc::Rc")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::cell::RefCell")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "solana_account_info::AccountInfo",
                                            "data"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_data_is_empty :
    M.IsAssociatedFunction.C Self "data_is_empty" data_is_empty.
  Admitted.
  Global Typeclasses Opaque data_is_empty.
  
  (*
      pub fn try_data_is_empty(&self) -> Result<bool, ProgramError> {
          Ok(self.try_borrow_data()?.is_empty())
      }
  *)
  Definition try_data_is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.path "bool"; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (Value.StructTuple
              "core::result::Result::Ok"
              []
              [ Ty.path "bool"; Ty.path "solana_program_error::ProgramError" ]
              [
                M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "is_empty",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.read (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::cell::Ref")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::cell::Ref")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                      ],
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "core::cell::Ref")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                        ],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::ops::control_flow::ControlFlow")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "solana_program_error::ProgramError"
                                              ];
                                            Ty.apply
                                              (Ty.path "core::cell::Ref")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ]
                                          ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "solana_program_error::ProgramError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::cell::Ref")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::cell::Ref")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ];
                                                Ty.path "solana_program_error::ProgramError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::cell::Ref")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [ Ty.path "u8" ]
                                                        ]
                                                    ];
                                                  Ty.path "solana_program_error::ProgramError"
                                                ],
                                              M.get_associated_function (|
                                                Ty.path "solana_account_info::AccountInfo",
                                                "try_borrow_data",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual :=
                                              M.copy (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "solana_program_error::ProgramError"
                                                  ],
                                                γ0_0
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.path "bool";
                                                        Ty.path "solana_program_error::ProgramError"
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path
                                                            "solana_program_error::ProgramError"
                                                        ],
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path
                                                              "solana_program_error::ProgramError"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val :=
                                              M.copy (|
                                                Ty.apply
                                                  (Ty.path "core::cell::Ref")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ],
                                                γ0_0
                                              |) in
                                            M.read (| val |)))
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_data_is_empty :
    M.IsAssociatedFunction.C Self "try_data_is_empty" try_data_is_empty.
  Admitted.
  Global Typeclasses Opaque try_data_is_empty.
  
  (*
      pub fn try_borrow_lamports(&self) -> Result<Ref<'_, &mut u64>, ProgramError> {
          self.lamports
              .try_borrow()
              .map_err(|_| ProgramError::AccountBorrowFailed)
      }
  *)
  Definition try_borrow_lamports (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.apply
                (Ty.path "core::cell::Ref")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
              Ty.path "solana_program_error::ProgramError"
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "core::cell::Ref")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                Ty.path "core::cell::BorrowError"
              ],
            "map_err",
            [],
            [
              Ty.path "solana_program_error::ProgramError";
              Ty.function
                [ Ty.path "core::cell::BorrowError" ]
                (Ty.path "solana_program_error::ProgramError")
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "core::cell::Ref")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                  Ty.path "core::cell::BorrowError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::cell::RefCell")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                "try_borrow",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::cell::RefCell")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ]
                        ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::cell::RefCell")
                              []
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_account_info::AccountInfo",
                            "lamports"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.path "solana_program_error::ProgramError",
                        M.alloc (| Ty.path "core::cell::BorrowError", α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "solana_program_error::ProgramError::AccountBorrowFailed"
                                []
                                []
                                []))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_borrow_lamports :
    M.IsAssociatedFunction.C Self "try_borrow_lamports" try_borrow_lamports.
  Admitted.
  Global Typeclasses Opaque try_borrow_lamports.
  
  (*
      pub fn try_borrow_mut_lamports(&self) -> Result<RefMut<'_, &'a mut u64>, ProgramError> {
          self.lamports
              .try_borrow_mut()
              .map_err(|_| ProgramError::AccountBorrowFailed)
      }
  *)
  Definition try_borrow_mut_lamports (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.apply
                (Ty.path "core::cell::RefMut")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
              Ty.path "solana_program_error::ProgramError"
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "core::cell::RefMut")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                Ty.path "core::cell::BorrowMutError"
              ],
            "map_err",
            [],
            [
              Ty.path "solana_program_error::ProgramError";
              Ty.function
                [ Ty.path "core::cell::BorrowMutError" ]
                (Ty.path "solana_program_error::ProgramError")
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "core::cell::RefMut")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                  Ty.path "core::cell::BorrowMutError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::cell::RefCell")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                "try_borrow_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::cell::RefCell")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ]
                        ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::cell::RefCell")
                              []
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_account_info::AccountInfo",
                            "lamports"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.path "solana_program_error::ProgramError",
                        M.alloc (| Ty.path "core::cell::BorrowMutError", α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "solana_program_error::ProgramError::AccountBorrowFailed"
                                []
                                []
                                []))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_borrow_mut_lamports :
    M.IsAssociatedFunction.C Self "try_borrow_mut_lamports" try_borrow_mut_lamports.
  Admitted.
  Global Typeclasses Opaque try_borrow_mut_lamports.
  
  (*
      pub fn try_borrow_data(&self) -> Result<Ref<'_, &mut [u8]>, ProgramError> {
          self.data
              .try_borrow()
              .map_err(|_| ProgramError::AccountBorrowFailed)
      }
  *)
  Definition try_borrow_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.apply
                (Ty.path "core::cell::Ref")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ];
              Ty.path "solana_program_error::ProgramError"
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "core::cell::Ref")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ];
                Ty.path "core::cell::BorrowError"
              ],
            "map_err",
            [],
            [
              Ty.path "solana_program_error::ProgramError";
              Ty.function
                [ Ty.path "core::cell::BorrowError" ]
                (Ty.path "solana_program_error::ProgramError")
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "core::cell::Ref")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ];
                  Ty.path "core::cell::BorrowError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::cell::RefCell")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ],
                "try_borrow",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::cell::RefCell")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ]
                        ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::cell::RefCell")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_account_info::AccountInfo",
                            "data"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.path "solana_program_error::ProgramError",
                        M.alloc (| Ty.path "core::cell::BorrowError", α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "solana_program_error::ProgramError::AccountBorrowFailed"
                                []
                                []
                                []))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_borrow_data :
    M.IsAssociatedFunction.C Self "try_borrow_data" try_borrow_data.
  Admitted.
  Global Typeclasses Opaque try_borrow_data.
  
  (*
      pub fn try_borrow_mut_data(&self) -> Result<RefMut<'_, &'a mut [u8]>, ProgramError> {
          self.data
              .try_borrow_mut()
              .map_err(|_| ProgramError::AccountBorrowFailed)
      }
  *)
  Definition try_borrow_mut_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.apply
                (Ty.path "core::cell::RefMut")
                []
                [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ];
              Ty.path "solana_program_error::ProgramError"
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "core::cell::RefMut")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ];
                Ty.path "core::cell::BorrowMutError"
              ],
            "map_err",
            [],
            [
              Ty.path "solana_program_error::ProgramError";
              Ty.function
                [ Ty.path "core::cell::BorrowMutError" ]
                (Ty.path "solana_program_error::ProgramError")
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "core::cell::RefMut")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ];
                  Ty.path "core::cell::BorrowMutError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::cell::RefCell")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ],
                "try_borrow_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::cell::RefCell")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ]
                        ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::cell::RefCell")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "solana_account_info::AccountInfo",
                            "data"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.path "solana_program_error::ProgramError",
                        M.alloc (| Ty.path "core::cell::BorrowMutError", α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "solana_program_error::ProgramError::AccountBorrowFailed"
                                []
                                []
                                []))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_try_borrow_mut_data :
    M.IsAssociatedFunction.C Self "try_borrow_mut_data" try_borrow_mut_data.
  Admitted.
  Global Typeclasses Opaque try_borrow_mut_data.
  
  (*
      pub fn resize(&self, new_len: usize) -> Result<(), ProgramError> {
          let mut data = self.try_borrow_mut_data()?;
          let old_len = data.len();
  
          // Return early if length hasn't changed
          if new_len == old_len {
              return Ok(());
          }
  
          // Return early if the length increase from the original serialized data
          // length is too large and would result in an out of bounds allocation.
          let original_data_len = unsafe { self.original_data_len() };
          if new_len.saturating_sub(original_data_len) > MAX_PERMITTED_DATA_INCREASE {
              return Err(ProgramError::InvalidRealloc);
          }
  
          // realloc
          unsafe {
              let data_ptr = data.as_mut_ptr();
  
              // First set new length in the serialized data
              *(data_ptr.offset(-8) as *mut u64) = new_len as u64;
  
              // Then recreate the local slice with the new length
              *data = from_raw_parts_mut(data_ptr, new_len)
          }
  
          let len_increase = new_len.saturating_sub(old_len);
          if len_increase > 0 {
              unsafe { sol_memset(&mut data[old_len..], 0, len_increase) };
          }
  
          Ok(())
      }
  *)
  Definition resize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; new_len ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        let new_len := M.alloc (| Ty.path "usize", new_len |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ data :
                  Ty.apply
                    (Ty.path "core::cell::RefMut")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ] :=
                M.match_operator (|
                  Ty.apply
                    (Ty.path "core::cell::RefMut")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::ops::control_flow::ControlFlow")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::convert::Infallible";
                            Ty.path "solana_program_error::ProgramError"
                          ];
                        Ty.apply
                          (Ty.path "core::cell::RefMut")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ]
                      ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "solana_program_error::ProgramError"
                            ];
                          Ty.apply
                            (Ty.path "core::cell::RefMut")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ]
                        ],
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::cell::RefMut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ];
                            Ty.path "solana_program_error::ProgramError"
                          ],
                        [],
                        [],
                        "branch",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::cell::RefMut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ];
                              Ty.path "solana_program_error::ProgramError"
                            ],
                          M.get_associated_function (|
                            Ty.path "solana_account_info::AccountInfo",
                            "try_borrow_mut_data",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "core::convert::Infallible";
                                Ty.path "solana_program_error::ProgramError"
                              ],
                            γ0_0
                          |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "solana_program_error::ProgramError"
                                      ]
                                  ],
                                  "from_residual",
                                  [],
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "core::cell::RefMut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            γ0_0
                          |) in
                        M.read (| val |)))
                  ]
                |) in
              let~ old_len : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "len",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.read (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::cell::RefMut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, data |) ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [ M.read (| new_len |); M.read (| old_len |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                []
                                [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                                [ Value.Tuple [] ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ original_data_len : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "solana_account_info::AccountInfo",
                    "original_data_len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "saturating_sub",
                                      [],
                                      []
                                    |),
                                    [ M.read (| new_len |); M.read (| original_data_len |) ]
                                  |);
                                  M.read (|
                                    get_constant (|
                                      "solana_account_info::MAX_PERMITTED_DATA_INCREASE",
                                      Ty.path "usize"
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                                [
                                  Value.StructTuple
                                    "solana_program_error::ProgramError::InvalidRealloc"
                                    []
                                    []
                                    []
                                ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  let~ data_ptr : Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] :=
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.read (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "core::cell::RefMut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                      ],
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.MutRef, data |) ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.write (|
                      M.deref (|
                        M.cast
                          (Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ])
                          (M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              "offset",
                              [],
                              []
                            |),
                            [ M.read (| data_ptr |); Value.Integer IntegerKind.Isize (-8) ]
                          |))
                      |),
                      M.cast (Ty.path "u64") (M.read (| new_len |))
                    |) in
                  M.alloc (|
                    Ty.tuple [],
                    M.write (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ],
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "core::cell::RefMut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            [],
                            [],
                            "deref_mut",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, data |) ]
                        |)
                      |),
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_function (|
                              "core::slice::raw::from_raw_parts_mut",
                              [],
                              [ Ty.path "u8" ]
                            |),
                            [ M.read (| data_ptr |); M.read (| new_len |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |) in
              let~ len_increase : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "saturating_sub", [], [] |),
                  [ M.read (| new_len |); M.read (| old_len |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [ M.read (| len_increase |); Value.Integer IntegerKind.Usize 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (| "solana_program_memory::sol_memset", [], [] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                          M.get_trait_method (|
                                            "core::ops::index::IndexMut",
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::RangeFrom")
                                                []
                                                [ Ty.path "usize" ]
                                            ],
                                            "index_mut",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.read (|
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&mut")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ]
                                                            ]
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::deref::DerefMut",
                                                        Ty.apply
                                                          (Ty.path "core::cell::RefMut")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&mut")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ]
                                                          ],
                                                        [],
                                                        [],
                                                        "deref_mut",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.MutRef, data |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |);
                                            Value.mkStructRecord
                                              "core::ops::range::RangeFrom"
                                              []
                                              [ Ty.path "usize" ]
                                              [ ("start", M.read (| old_len |)) ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |);
                                Value.Integer IntegerKind.U8 0;
                                M.read (| len_increase |)
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                  [ Value.Tuple [] ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_resize : M.IsAssociatedFunction.C Self "resize" resize.
  Admitted.
  Global Typeclasses Opaque resize.
  
  (*
      pub fn assign(&self, new_owner: &Pubkey) {
          // Set the non-mut owner field
          unsafe {
              std::ptr::write_volatile(
                  self.owner as *const Pubkey as *mut [u8; 32],
                  new_owner.to_bytes(),
              );
          }
      }
  *)
  Definition assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; new_owner ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        let new_owner :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
            new_owner
          |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_function (|
                "core::ptr::write_volatile",
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ]
                ]
              |),
              [
                M.cast
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        [ Ty.path "u8" ]
                    ])
                  (M.read (|
                    M.use
                      (M.alloc (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "solana_address::Address" ],
                        M.borrow (|
                          Pointer.Kind.ConstPointer,
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "solana_account_info::AccountInfo",
                                "owner"
                              |)
                            |)
                          |)
                        |)
                      |))
                  |));
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.path "solana_address::Address",
                    "to_bytes",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| new_owner |) |) |) ]
                |)
              ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_assign : M.IsAssociatedFunction.C Self "assign" assign.
  Admitted.
  Global Typeclasses Opaque assign.
  
  (*
      pub fn new(
          key: &'a Pubkey,
          is_signer: bool,
          is_writable: bool,
          lamports: &'a mut u64,
          data: &'a mut [u8],
          owner: &'a Pubkey,
          executable: bool,
      ) -> Self {
          #[allow(deprecated)]
          Self {
              key,
              is_signer,
              is_writable,
              lamports: Rc::new(RefCell::new(lamports)),
              data: Rc::new(RefCell::new(data)),
              owner,
              executable,
              _unused: 0,
          }
      }
  *)
  Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ key; is_signer; is_writable; lamports; data; owner; executable ] =>
      ltac:(M.monadic
        (let key :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], key |) in
        let is_signer := M.alloc (| Ty.path "bool", is_signer |) in
        let is_writable := M.alloc (| Ty.path "bool", is_writable |) in
        let lamports := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], lamports |) in
        let data :=
          M.alloc (|
            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            data
          |) in
        let owner :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ], owner |) in
        let executable := M.alloc (| Ty.path "bool", executable |) in
        Value.mkStructRecord
          "solana_account_info::AccountInfo"
          []
          []
          [
            ("key", M.read (| key |));
            ("is_signer", M.read (| is_signer |));
            ("is_writable", M.read (| is_writable |));
            ("lamports",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::cell::RefCell")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::cell::RefCell")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                      "new",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lamports |) |) |) ]
                  |)
                ]
              |));
            ("data",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::cell::RefCell")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::cell::RefCell")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                      "new",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |) ]
                  |)
                ]
              |));
            ("owner", M.read (| owner |));
            ("executable", M.read (| executable |));
            ("_unused", Value.Integer IntegerKind.U64 0)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
  Admitted.
  Global Typeclasses Opaque new.
End Impl_solana_account_info_AccountInfo.

(* Trait *)
(* Empty module 'IntoAccountInfo' *)

Module Impl_core_convert_From_where_solana_account_info_IntoAccountInfo_T_T_for_solana_account_info_AccountInfo.
  Definition Self (T : Ty.t) : Ty.t := Ty.path "solana_account_info::AccountInfo".
  
  (*
      fn from(src: T) -> Self {
          src.into_account_info()
      }
  *)
  Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ src ] =>
      ltac:(M.monadic
        (let src := M.alloc (| T, src |) in
        M.call_closure (|
          Ty.path "solana_account_info::AccountInfo",
          M.get_trait_method (|
            "solana_account_info::IntoAccountInfo",
            T,
            [],
            [],
            "into_account_info",
            [],
            []
          |),
          [ M.read (| src |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ T ]
      (Self T)
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_where_solana_account_info_IntoAccountInfo_T_T_for_solana_account_info_AccountInfo.

(* Trait *)
(* Empty module 'Account' *)

Module Impl_solana_account_info_IntoAccountInfo_where_solana_account_info_Account_T_for_Tuple_ref__solana_address_Address_ref_mut_T_.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.tuple
      [
        Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
        Ty.apply (Ty.path "&mut") [] [ T ]
      ].
  
  (*
      fn into_account_info(self) -> AccountInfo<'a> {
          let (key, account) = self;
          let (lamports, data, owner, executable) = account.get();
          AccountInfo::new(key, false, false, lamports, data, owner, executable)
      }
  *)
  Definition into_account_info
      (T : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                Ty.apply (Ty.path "&mut") [] [ T ]
              ],
            self
          |) in
        M.match_operator (|
          Ty.path "solana_account_info::AccountInfo",
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let key :=
                  M.copy (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                    γ0_0
                  |) in
                let account := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_1 |) in
                M.match_operator (|
                  Ty.path "solana_account_info::AccountInfo",
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                        Ty.path "bool"
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                          Ty.path "bool"
                        ],
                      M.get_trait_method (|
                        "solana_account_info::Account",
                        T,
                        [],
                        [],
                        "get",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| account |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                        let lamports :=
                          M.copy (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], γ0_0 |) in
                        let data :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            γ0_1
                          |) in
                        let owner :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                            γ0_2
                          |) in
                        let executable := M.copy (| Ty.path "bool", γ0_3 |) in
                        M.call_closure (|
                          Ty.path "solana_account_info::AccountInfo",
                          M.get_associated_function (|
                            Ty.path "solana_account_info::AccountInfo",
                            "new",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| key |) |) |);
                            Value.Bool false;
                            Value.Bool false;
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lamports |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| owner |) |) |);
                            M.read (| executable |)
                          ]
                        |)))
                  ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "solana_account_info::IntoAccountInfo"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("into_account_info", InstanceField.Method (into_account_info T)) ].
End Impl_solana_account_info_IntoAccountInfo_where_solana_account_info_Account_T_for_Tuple_ref__solana_address_Address_ref_mut_T_.

Module Impl_solana_account_info_IntoAccountInfo_where_solana_account_info_Account_T_for_Tuple_ref__solana_address_Address_bool_ref_mut_T_.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.tuple
      [
        Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
        Ty.path "bool";
        Ty.apply (Ty.path "&mut") [] [ T ]
      ].
  
  (*
      fn into_account_info(self) -> AccountInfo<'a> {
          let (key, is_signer, account) = self;
          let (lamports, data, owner, executable) = account.get();
          AccountInfo::new(key, is_signer, false, lamports, data, owner, executable)
      }
  *)
  Definition into_account_info
      (T : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                Ty.path "bool";
                Ty.apply (Ty.path "&mut") [] [ T ]
              ],
            self
          |) in
        M.match_operator (|
          Ty.path "solana_account_info::AccountInfo",
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                let key :=
                  M.copy (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                    γ0_0
                  |) in
                let is_signer := M.copy (| Ty.path "bool", γ0_1 |) in
                let account := M.copy (| Ty.apply (Ty.path "&mut") [] [ T ], γ0_2 |) in
                M.match_operator (|
                  Ty.path "solana_account_info::AccountInfo",
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                        Ty.path "bool"
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                          Ty.path "bool"
                        ],
                      M.get_trait_method (|
                        "solana_account_info::Account",
                        T,
                        [],
                        [],
                        "get",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| account |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                        let lamports :=
                          M.copy (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], γ0_0 |) in
                        let data :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            γ0_1
                          |) in
                        let owner :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                            γ0_2
                          |) in
                        let executable := M.copy (| Ty.path "bool", γ0_3 |) in
                        M.call_closure (|
                          Ty.path "solana_account_info::AccountInfo",
                          M.get_associated_function (|
                            Ty.path "solana_account_info::AccountInfo",
                            "new",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| key |) |) |);
                            M.read (| is_signer |);
                            Value.Bool false;
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lamports |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| owner |) |) |);
                            M.read (| executable |)
                          ]
                        |)))
                  ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "solana_account_info::IntoAccountInfo"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("into_account_info", InstanceField.Method (into_account_info T)) ].
End Impl_solana_account_info_IntoAccountInfo_where_solana_account_info_Account_T_for_Tuple_ref__solana_address_Address_bool_ref_mut_T_.

Module Impl_solana_account_info_IntoAccountInfo_where_solana_account_info_Account_T_for_ref_mut_Tuple_solana_address_Address_T_.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "&mut") [] [ Ty.tuple [ Ty.path "solana_address::Address"; T ] ].
  
  (*
      fn into_account_info(self) -> AccountInfo<'a> {
          let (ref key, account) = self;
          let (lamports, data, owner, executable) = account.get();
          AccountInfo::new(key, false, false, lamports, data, owner, executable)
      }
  *)
  Definition into_account_info
      (T : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&mut") [] [ Ty.tuple [ Ty.path "solana_address::Address"; T ] ],
            self
          |) in
        M.match_operator (|
          Ty.path "solana_account_info::AccountInfo",
          self,
          [
            fun γ =>
              ltac:(M.monadic
                (let γ := M.deref (| M.read (| γ |) |) in
                let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                let key :=
                  M.alloc (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                    γ1_0
                  |) in
                let account := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], γ1_1 |) in
                M.match_operator (|
                  Ty.path "solana_account_info::AccountInfo",
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                        Ty.path "bool"
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                          Ty.path "bool"
                        ],
                      M.get_trait_method (|
                        "solana_account_info::Account",
                        T,
                        [],
                        [],
                        "get",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| account |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                        let lamports :=
                          M.copy (| Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ], γ0_0 |) in
                        let data :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            γ0_1
                          |) in
                        let owner :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                            γ0_2
                          |) in
                        let executable := M.copy (| Ty.path "bool", γ0_3 |) in
                        M.call_closure (|
                          Ty.path "solana_account_info::AccountInfo",
                          M.get_associated_function (|
                            Ty.path "solana_account_info::AccountInfo",
                            "new",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| key |) |) |);
                            Value.Bool false;
                            Value.Bool false;
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lamports |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| owner |) |) |);
                            M.read (| executable |)
                          ]
                        |)))
                  ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "solana_account_info::IntoAccountInfo"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self T)
      (* Instance *) [ ("into_account_info", InstanceField.Method (into_account_info T)) ].
End Impl_solana_account_info_IntoAccountInfo_where_solana_account_info_Account_T_for_ref_mut_Tuple_solana_address_Address_T_.

(*
pub fn next_account_info<'a, 'b, I: Iterator<Item = &'a AccountInfo<'b>>>(
    iter: &mut I,
) -> Result<I::Item, ProgramError> {
    iter.next().ok_or(ProgramError::NotEnoughAccountKeys)
}
*)
Definition next_account_info (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [ _ as I ], [ iter ] =>
    ltac:(M.monadic
      (let iter := M.alloc (| Ty.apply (Ty.path "&mut") [] [ I ], iter |) in
      M.call_closure (|
        Ty.apply
          (Ty.path "core::result::Result")
          []
          [
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ];
            Ty.path "solana_program_error::ProgramError"
          ],
        M.get_associated_function (|
          Ty.apply
            (Ty.path "core::option::Option")
            []
            [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ] ],
          "ok_or",
          [],
          [ Ty.path "solana_program_error::ProgramError" ]
        |),
        [
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              I,
              [],
              [],
              "next",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| iter |) |) |) ]
          |);
          Value.StructTuple "solana_program_error::ProgramError::NotEnoughAccountKeys" [] [] []
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_next_account_info :
  M.IsFunction.C "solana_account_info::next_account_info" next_account_info.
Admitted.
Global Typeclasses Opaque next_account_info.

(*
pub fn next_account_infos<'a, 'b: 'a>(
    iter: &mut std::slice::Iter<'a, AccountInfo<'b>>,
    count: usize,
) -> Result<&'a [AccountInfo<'b>], ProgramError> {
    let accounts = iter.as_slice();
    if accounts.len() < count {
        return Err(ProgramError::NotEnoughAccountKeys);
    }
    let (accounts, remaining) = accounts.split_at(count);
    *iter = remaining.iter();
    Ok(accounts)
}
*)
Definition next_account_infos (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ iter; count ] =>
    ltac:(M.monadic
      (let iter :=
        M.alloc (|
          Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                []
                [ Ty.path "solana_account_info::AccountInfo" ]
            ],
          iter
        |) in
      let count := M.alloc (| Ty.path "usize", count |) in
      M.catch_return
        (Ty.apply
          (Ty.path "core::result::Result")
          []
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ] ];
            Ty.path "solana_program_error::ProgramError"
          ]) (|
        ltac:(M.monadic
          (M.read (|
            let~ accounts :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ]
                  ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::slice::iter::Iter")
                    []
                    [ Ty.path "solana_account_info::AccountInfo" ],
                  "as_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| iter |) |) |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "solana_account_info::AccountInfo" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| accounts |) |)
                                    |)
                                  ]
                                |);
                                M.read (| count |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "solana_account_info::AccountInfo" ]
                                  ];
                                Ty.path "solana_program_error::ProgramError"
                              ]
                              [
                                Value.StructTuple
                                  "solana_program_error::ProgramError::NotEnoughAccountKeys"
                                  []
                                  []
                                  []
                              ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ]
                    ];
                  Ty.path "solana_program_error::ProgramError"
                ],
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ]
                      ];
                    Ty.path "solana_program_error::ProgramError"
                  ],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.path "solana_account_info::AccountInfo" ]
                        ];
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.path "solana_account_info::AccountInfo" ]
                        ]
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.path "solana_account_info::AccountInfo" ]
                          ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.path "solana_account_info::AccountInfo" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ],
                      "split_at",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| accounts |) |) |);
                      M.read (| count |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let accounts :=
                        M.copy (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "solana_account_info::AccountInfo" ]
                            ],
                          γ0_0
                        |) in
                      let remaining :=
                        M.copy (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "solana_account_info::AccountInfo" ]
                            ],
                          γ0_1
                        |) in
                      M.read (|
                        let~ _ : Ty.tuple [] :=
                          M.write (|
                            M.deref (| M.read (| iter |) |),
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                []
                                [ Ty.path "solana_account_info::AccountInfo" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.path "solana_account_info::AccountInfo" ],
                                "iter",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| remaining |) |)
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "solana_account_info::AccountInfo" ]
                                ];
                              Ty.path "solana_program_error::ProgramError"
                            ],
                          Value.StructTuple
                            "core::result::Result::Ok"
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "solana_account_info::AccountInfo" ]
                                ];
                              Ty.path "solana_program_error::ProgramError"
                            ]
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| accounts |) |) |) ]
                        |)
                      |)))
                ]
              |)
            |)
          |)))
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_next_account_infos :
  M.IsFunction.C "solana_account_info::next_account_infos" next_account_infos.
Admitted.
Global Typeclasses Opaque next_account_infos.

Module Impl_core_convert_AsRef_solana_account_info_AccountInfo_for_solana_account_info_AccountInfo.
  Definition Self : Ty.t := Ty.path "solana_account_info::AccountInfo".
  
  (*
      fn as_ref(&self) -> &AccountInfo<'a> {
          self
      }
  *)
  Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_account_info::AccountInfo" ],
            self
          |) in
        M.read (| self |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::AsRef"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "solana_account_info::AccountInfo" ]
      Self
      (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
End Impl_core_convert_AsRef_solana_account_info_AccountInfo_for_solana_account_info_AccountInfo.

(*
pub fn check_type_assumptions() {
    use std::mem::offset_of;

    let key = Pubkey::new_from_array([10; 32]);
    let mut lamports = 31;
    let mut data = vec![1, 2, 3, 4, 5];
    let owner = Pubkey::new_from_array([22; 32]);
    let account_info = AccountInfo::new(&key, true, false, &mut lamports, &mut data, &owner, true);
    let account_info_addr = &account_info as *const _ as u64;

    // key
    assert_eq!(offset_of!(AccountInfo, key), 0);
    let key_ptr = (account_info_addr) as *const &Pubkey;
    unsafe {
        assert_eq!( **key_ptr, key);
    }

    // lamports
    assert_eq!(offset_of!(AccountInfo, lamports), 8);
    let lamports_ptr = (account_info_addr + 8) as *const Rc<RefCell<&mut u64>>;
    unsafe {
        assert_eq!( **( *lamports_ptr).as_ptr(), 31);
    }

    // data
    assert_eq!(offset_of!(AccountInfo, data), 16);
    let data_ptr = (account_info_addr + 16) as *const Rc<RefCell<&mut [u8]>>;
    unsafe {
        assert_eq!((&( *( *data_ptr).as_ptr()))[..], data[..]);
    }

    // owner
    assert_eq!(offset_of!(AccountInfo, owner), 24);
    let owner_ptr = (account_info_addr + 24) as *const &Pubkey;
    unsafe {
        assert_eq!( **owner_ptr, owner);
    }

    // previously rent_epoch
    #[allow(deprecated)]
    {
        assert_eq!(offset_of!(AccountInfo, _unused), 32);
        let unused_ptr = (account_info_addr + 32) as *const u64;
        unsafe {
            assert_eq!( *unused_ptr, 0);
        }
    }

    // is_signer
    assert_eq!(offset_of!(AccountInfo, is_signer), 40);
    let is_signer_ptr = (account_info_addr + 40) as *const bool;
    unsafe {
        assert!( *is_signer_ptr);
    }

    // is_writable
    assert_eq!(offset_of!(AccountInfo, is_writable), 41);
    let is_writable_ptr = (account_info_addr + 41) as *const bool;
    unsafe {
        assert!(!*is_writable_ptr);
    }

    // executable
    assert_eq!(offset_of!(AccountInfo, executable), 42);
    let executable_ptr = (account_info_addr + 42) as *const bool;
    unsafe {
        assert!( *executable_ptr);
    }
}
*)
Definition check_type_assumptions (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [] =>
    ltac:(M.monadic
      (M.read (|
        let~ key : Ty.path "solana_address::Address" :=
          M.call_closure (|
            Ty.path "solana_address::Address",
            M.get_associated_function (|
              Ty.path "solana_address::Address",
              "new_from_array",
              [],
              []
            |),
            [ lib.repeat (| Value.Integer IntegerKind.U8 10, Value.Integer IntegerKind.Usize 32 |) ]
          |) in
        let~ lamports : Ty.path "u64" := Value.Integer IntegerKind.U64 31 in
        let~ data :
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] :=
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              "into_vec",
              [],
              [ Ty.path "alloc::alloc::Global" ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                  ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 5 ]
                        [ Ty.path "u8" ];
                      Ty.path "alloc::alloc::Global"
                    ])
                  (Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ]),
                [
                  M.read (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 5 ]
                            [ Ty.path "u8" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 5 ]
                              [ Ty.path "u8" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.alloc (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 5 ]
                            [ Ty.path "u8" ],
                          Value.Array
                            [
                              Value.Integer IntegerKind.U8 1;
                              Value.Integer IntegerKind.U8 2;
                              Value.Integer IntegerKind.U8 3;
                              Value.Integer IntegerKind.U8 4;
                              Value.Integer IntegerKind.U8 5
                            ]
                        |)
                      ]
                    |)
                  |)
                ]
              |)
            ]
          |) in
        let~ owner : Ty.path "solana_address::Address" :=
          M.call_closure (|
            Ty.path "solana_address::Address",
            M.get_associated_function (|
              Ty.path "solana_address::Address",
              "new_from_array",
              [],
              []
            |),
            [ lib.repeat (| Value.Integer IntegerKind.U8 22, Value.Integer IntegerKind.Usize 32 |) ]
          |) in
        let~ account_info : Ty.path "solana_account_info::AccountInfo" :=
          M.call_closure (|
            Ty.path "solana_account_info::AccountInfo",
            M.get_associated_function (|
              Ty.path "solana_account_info::AccountInfo",
              "new",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, key |) |) |);
              Value.Bool true;
              Value.Bool false;
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.borrow (| Pointer.Kind.MutRef, lamports |) |)
              |);
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::DerefMut",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "deref_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (| M.borrow (| Pointer.Kind.MutRef, data |) |)
                      |)
                    ]
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, owner |) |) |);
              Value.Bool true
            ]
          |) in
        let~ account_info_addr : Ty.path "u64" :=
          M.cast
            (Ty.path "u64")
            (M.read (|
              M.use
                (M.alloc (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "solana_account_info::AccountInfo" ],
                  M.borrow (|
                    Pointer.Kind.ConstPointer,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, account_info |) |)
                  |)
                |))
            |)) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 0 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ key_ptr :
            Ty.apply
              (Ty.path "*const")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ] :=
          M.cast
            (Ty.apply
              (Ty.path "*const")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ])
            (M.read (| account_info_addr |)) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| key_ptr |) |) |) |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, key |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                          γ0_0
                        |) in
                      let right_val :=
                        M.copy (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                          γ0_1
                        |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      UnOp.not,
                                      [
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.path "solana_address::Address",
                                            [],
                                            [ Ty.path "solana_address::Address" ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [
                                          Ty.path "solana_address::Address";
                                          Ty.path "solana_address::Address"
                                        ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 8 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ lamports_ptr :
            Ty.apply
              (Ty.path "*const")
              []
              [
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ] :=
          M.cast
            (Ty.apply
              (Ty.path "*const")
              []
              [
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ])
            (M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 8 ]
            |)) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.read (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::cell::RefCell")
                                    []
                                    [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::cell::RefCell")
                                              []
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ]
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::rc::Rc")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::cell::RefCell")
                                                []
                                                [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| lamports_ptr |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 31 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      UnOp.not,
                                      [
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "u64"; Ty.path "u64" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 16 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ data_ptr :
            Ty.apply
              (Ty.path "*const")
              []
              [
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ] :=
          M.cast
            (Ty.apply
              (Ty.path "*const")
              []
              [
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::cell::RefCell")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ])
            (M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 16 ]
            |)) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              [],
                              [ Ty.path "core::ops::range::RangeFull" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::cell::RefCell")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ]
                                                ],
                                              "as_ptr",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::cell::RefCell")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&mut")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ]
                                                          ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::Rc")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::cell::RefCell")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&mut")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ Ty.path "u8" ]
                                                                ]
                                                            ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| data_ptr |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |);
                              Value.StructTuple "core::ops::range::RangeFull" [] [] []
                            ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.path "core::ops::range::RangeFull" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, data |);
                              Value.StructTuple "core::ops::range::RangeFull" [] [] []
                            ]
                          |)
                        |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          γ0_0
                        |) in
                      let right_val :=
                        M.copy (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          γ0_1
                        |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      UnOp.not,
                                      [
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                            [],
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                        ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 24 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ owner_ptr :
            Ty.apply
              (Ty.path "*const")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ] :=
          M.cast
            (Ty.apply
              (Ty.path "*const")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ] ])
            (M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 24 ]
            |)) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| owner_ptr |) |) |) |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, owner |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                          γ0_0
                        |) in
                      let right_val :=
                        M.copy (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
                          γ0_1
                        |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      UnOp.not,
                                      [
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.path "solana_address::Address",
                                            [],
                                            [ Ty.path "solana_address::Address" ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [
                                          Ty.path "solana_address::Address";
                                          Ty.path "solana_address::Address"
                                        ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        (* `OffsetOf` expression are not handled yet *)
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 32 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      UnOp.not,
                                      [
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ unused_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u64" ] :=
              M.cast
                (Ty.apply (Ty.path "*const") [] [ Ty.path "u64" ])
                (M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.add,
                  [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 32 ]
                |)) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| unused_ptr |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 0 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      UnOp.not,
                                      [
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "u64"; Ty.path "u64" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 40 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ is_signer_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "bool" ] :=
          M.cast
            (Ty.apply (Ty.path "*const") [] [ Ty.path "bool" ])
            (M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 40 ]
            |)) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              UnOp.not,
                              [ M.read (| M.deref (| M.read (| is_signer_ptr |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: *is_signer_ptr" |) ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 41 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ is_writable_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "bool" ] :=
          M.cast
            (Ty.apply (Ty.path "*const") [] [ Ty.path "bool" ])
            (M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 41 ]
            |)) in
        let~ _ : Ty.tuple [] :=
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              UnOp.not,
                              [
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [ M.read (| M.deref (| M.read (| is_writable_ptr |) |) |) ]
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: !*is_writable_ptr" |) ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                ],
              Value.Tuple
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    (* `OffsetOf` expression are not handled yet *)
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 42 |)
                  |)
                ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                  let right_val :=
                    M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  UnOp.not,
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                              M.alloc (|
                                Ty.path "never",
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (|
                                    "core::panicking::assert_failed",
                                    [],
                                    [ Ty.path "usize"; Ty.path "usize" ]
                                  |),
                                  [
                                    M.read (| kind |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| left_val |) |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| right_val |) |)
                                        |)
                                      |)
                                    |);
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [ Ty.path "core::fmt::Arguments" ]
                                      []
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |)))
            ]
          |) in
        let~ executable_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "bool" ] :=
          M.cast
            (Ty.apply (Ty.path "*const") [] [ Ty.path "bool" ])
            (M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| account_info_addr |); Value.Integer IntegerKind.U64 42 ]
            |)) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          UnOp.not,
                          [ M.read (| M.deref (| M.read (| executable_ptr |) |) |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic", [], [] |),
                      [ mk_str (| "assertion failed: *executable_ptr" |) ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |) in
        M.alloc (| Ty.tuple [], Value.Tuple [] |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_check_type_assumptions :
  M.IsFunction.C "solana_account_info::check_type_assumptions" check_type_assumptions.
Admitted.
Global Typeclasses Opaque check_type_assumptions.
