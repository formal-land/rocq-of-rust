(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

(*
pub fn ui_amount_to_amount(ui_amount: f64, decimals: u8) -> u64 {
    (ui_amount * 10_usize.pow(decimals as u32) as f64) as u64
}
*)
Definition ui_amount_to_amount (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ ui_amount; decimals ] =>
    ltac:(M.monadic
      (let ui_amount := M.alloc (| Ty.path "f64", ui_amount |) in
      let decimals := M.alloc (| Ty.path "u8", decimals |) in
      M.cast
        (Ty.path "u64")
        (M.call_closure (|
          Ty.path "f64",
          BinOp.Wrap.mul,
          [
            M.read (| ui_amount |);
            M.cast
              (Ty.path "f64")
              (M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.path "usize", "pow", [], [] |),
                [ Value.Integer IntegerKind.Usize 10; M.cast (Ty.path "u32") (M.read (| decimals |))
                ]
              |))
          ]
        |))))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_ui_amount_to_amount :
  M.IsFunction.C "spl_token::ui_amount_to_amount" ui_amount_to_amount.
Admitted.
Global Typeclasses Opaque ui_amount_to_amount.

(*
pub fn amount_to_ui_amount(amount: u64, decimals: u8) -> f64 {
    amount as f64 / 10_usize.pow(decimals as u32) as f64
}
*)
Definition amount_to_ui_amount (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ amount; decimals ] =>
    ltac:(M.monadic
      (let amount := M.alloc (| Ty.path "u64", amount |) in
      let decimals := M.alloc (| Ty.path "u8", decimals |) in
      M.call_closure (|
        Ty.path "f64",
        BinOp.Wrap.div,
        [
          M.cast (Ty.path "f64") (M.read (| amount |));
          M.cast
            (Ty.path "f64")
            (M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (| Ty.path "usize", "pow", [], [] |),
              [ Value.Integer IntegerKind.Usize 10; M.cast (Ty.path "u32") (M.read (| decimals |)) ]
            |))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_amount_to_ui_amount :
  M.IsFunction.C "spl_token::amount_to_ui_amount" amount_to_ui_amount.
Admitted.
Global Typeclasses Opaque amount_to_ui_amount.

(*
pub fn amount_to_ui_amount_string(amount: u64, decimals: u8) -> String {
    let decimals = decimals as usize;
    if decimals > 0 {
        // Left-pad zeros to decimals + 1, so we at least have an integer zero
        let mut s = format!("{:01$}", amount, decimals + 1);
        // Add the decimal point (Sorry, "," locales!)
        s.insert(s.len() - decimals, '.');
        s
    } else {
        amount.to_string()
    }
}
*)
Definition amount_to_ui_amount_string (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ amount; decimals ] =>
    ltac:(M.monadic
      (let amount := M.alloc (| Ty.path "u64", amount |) in
      let decimals := M.alloc (| Ty.path "u8", decimals |) in
      M.read (|
        let~ decimals : Ty.path "usize" := M.cast (Ty.path "usize") (M.read (| decimals |)) in
        M.alloc (|
          Ty.path "alloc::string::String",
          M.match_operator (|
            Ty.path "alloc::string::String",
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.gt,
                          [ M.read (| decimals |); Value.Integer IntegerKind.Usize 0 ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.read (|
                    let~ s : Ty.path "alloc::string::String" :=
                      M.call_closure (|
                        Ty.path "alloc::string::String",
                        M.get_function (|
                          "core::hint::must_use",
                          [],
                          [ Ty.path "alloc::string::String" ]
                        |),
                        [
                          M.read (|
                            let~ res : Ty.path "alloc::string::String" :=
                              M.call_closure (|
                                Ty.path "alloc::string::String",
                                M.get_function (| "alloc::fmt::format", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1_formatted",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                          ],
                                        M.pointer_coercion
                                          M.PointerCoercion.Unsize
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                            ])
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                            ]),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 1 ]
                                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                                  Value.Array [ mk_str (| "" |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [ Ty.path "core::fmt::rt::Argument" ]
                                          ],
                                        M.pointer_coercion
                                          M.PointerCoercion.Unsize
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 2 ]
                                                [ Ty.path "core::fmt::rt::Argument" ]
                                            ])
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::fmt::rt::Argument" ]
                                            ]),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [ Ty.path "core::fmt::rt::Argument" ],
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [],
                                                          [ Ty.path "u64" ]
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                amount
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "from_usize",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.alloc (|
                                                                  Ty.path "usize",
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    BinOp.Wrap.add,
                                                                    [
                                                                      M.read (| decimals |);
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [ Ty.path "core::fmt::rt::Placeholder" ]
                                          ],
                                        M.pointer_coercion
                                          M.PointerCoercion.Unsize
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.path "core::fmt::rt::Placeholder" ]
                                            ])
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::fmt::rt::Placeholder" ]
                                            ]),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 1 ]
                                                    [ Ty.path "core::fmt::rt::Placeholder" ],
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::rt::Placeholder",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Placeholder",
                                                          "new",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          Value.Integer IntegerKind.Usize 0;
                                                          Value.UnicodeChar 32;
                                                          Value.StructTuple
                                                            "core::fmt::rt::Alignment::Unknown"
                                                            []
                                                            []
                                                            [];
                                                          Value.Integer IntegerKind.U32 8;
                                                          Value.StructTuple
                                                            "core::fmt::rt::Count::Implied"
                                                            []
                                                            []
                                                            [];
                                                          Value.StructTuple
                                                            "core::fmt::rt::Count::Param"
                                                            []
                                                            []
                                                            [ Value.Integer IntegerKind.Usize 1 ]
                                                        ]
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::UnsafeArg",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::UnsafeArg",
                                          "new",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    ]
                                  |)
                                ]
                              |) in
                            res
                          |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.path "alloc::string::String",
                          "insert",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, s |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.sub,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "alloc::string::String",
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, s |) ]
                              |);
                              M.read (| decimals |)
                            ]
                          |);
                          Value.UnicodeChar 46
                        ]
                      |) in
                    s
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "alloc::string::String",
                    M.get_trait_method (|
                      "alloc::string::ToString",
                      Ty.path "u64",
                      [],
                      [],
                      "to_string",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, amount |) ]
                  |)))
            ]
          |)
        |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_amount_to_ui_amount_string :
  M.IsFunction.C "spl_token::amount_to_ui_amount_string" amount_to_ui_amount_string.
Admitted.
Global Typeclasses Opaque amount_to_ui_amount_string.

(*
pub fn amount_to_ui_amount_string_trimmed(amount: u64, decimals: u8) -> String {
    let mut s = amount_to_ui_amount_string(amount, decimals);
    if decimals > 0 {
        let zeros_trimmed = s.trim_end_matches('0');
        s = zeros_trimmed.trim_end_matches('.').to_string();
    }
    s
}
*)
Definition amount_to_ui_amount_string_trimmed
    (ε : list Value.t)
    (τ : list Ty.t)
    (α : list Value.t)
    : M :=
  match ε, τ, α with
  | [], [], [ amount; decimals ] =>
    ltac:(M.monadic
      (let amount := M.alloc (| Ty.path "u64", amount |) in
      let decimals := M.alloc (| Ty.path "u8", decimals |) in
      M.read (|
        let~ s : Ty.path "alloc::string::String" :=
          M.call_closure (|
            Ty.path "alloc::string::String",
            M.get_function (| "spl_token::amount_to_ui_amount_string", [], [] |),
            [ M.read (| amount |); M.read (| decimals |) ]
          |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.gt,
                          [ M.read (| decimals |); Value.Integer IntegerKind.U8 0 ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.read (|
                    let~ zeros_trimmed : Ty.apply (Ty.path "&") [] [ Ty.path "str" ] :=
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                        M.get_associated_function (|
                          Ty.path "str",
                          "trim_end_matches",
                          [],
                          [ Ty.path "char" ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "alloc::string::String",
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, s |) ]
                              |)
                            |)
                          |);
                          Value.UnicodeChar 48
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.write (|
                        s,
                        M.call_closure (|
                          Ty.path "alloc::string::String",
                          M.get_trait_method (|
                            "alloc::string::ToString",
                            Ty.path "str",
                            [],
                            [],
                            "to_string",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                  M.get_associated_function (|
                                    Ty.path "str",
                                    "trim_end_matches",
                                    [],
                                    [ Ty.path "char" ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| zeros_trimmed |) |)
                                    |);
                                    Value.UnicodeChar 46
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |) in
        s
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_amount_to_ui_amount_string_trimmed :
  M.IsFunction.C "spl_token::amount_to_ui_amount_string_trimmed" amount_to_ui_amount_string_trimmed.
Admitted.
Global Typeclasses Opaque amount_to_ui_amount_string_trimmed.

(*
pub fn try_ui_amount_into_amount(ui_amount: String, decimals: u8) -> Result<u64, ProgramError> {
    let decimals = decimals as usize;
    let mut parts = ui_amount.split('.');
    // splitting a string, even an empty one, will always yield an iterator of
    // at least length == 1
    let mut amount_str = parts.next().unwrap().to_string();
    let after_decimal = parts.next().unwrap_or("");
    let after_decimal = after_decimal.trim_end_matches('0');
    if (amount_str.is_empty() && after_decimal.is_empty())
        || parts.next().is_some()
        || after_decimal.len() > decimals
    {
        return Err(ProgramError::InvalidArgument);
    }

    amount_str.push_str(after_decimal);
    for _ in 0..decimals.saturating_sub(after_decimal.len()) {
        amount_str.push('0');
    }
    amount_str
        .parse::<u64>()
        .map_err(|_| ProgramError::InvalidArgument)
}
*)
Definition try_ui_amount_into_amount (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ ui_amount; decimals ] =>
    ltac:(M.monadic
      (let ui_amount := M.alloc (| Ty.path "alloc::string::String", ui_amount |) in
      let decimals := M.alloc (| Ty.path "u8", decimals |) in
      M.catch_return
        (Ty.apply
          (Ty.path "core::result::Result")
          []
          [ Ty.path "u64"; Ty.path "solana_program_error::ProgramError" ]) (|
        ltac:(M.monadic
          (M.read (|
            let~ decimals : Ty.path "usize" := M.cast (Ty.path "usize") (M.read (| decimals |)) in
            let~ parts : Ty.apply (Ty.path "core::str::iter::Split") [] [ Ty.path "char" ] :=
              M.call_closure (|
                Ty.apply (Ty.path "core::str::iter::Split") [] [ Ty.path "char" ],
                M.get_associated_function (| Ty.path "str", "split", [], [ Ty.path "char" ] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "alloc::string::String",
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, ui_amount |) ]
                      |)
                    |)
                  |);
                  Value.UnicodeChar 46
                ]
              |) in
            let~ amount_str : Ty.path "alloc::string::String" :=
              M.call_closure (|
                Ty.path "alloc::string::String",
                M.get_trait_method (|
                  "alloc::string::ToString",
                  Ty.path "str",
                  [],
                  [],
                  "to_string",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                          "unwrap",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply (Ty.path "core::str::iter::Split") [] [ Ty.path "char" ],
                              [],
                              [],
                              "next",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, parts |) ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |) in
            let~ after_decimal : Ty.apply (Ty.path "&") [] [ Ty.path "str" ] :=
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  "unwrap_or",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::str::iter::Split") [] [ Ty.path "char" ],
                      [],
                      [],
                      "next",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, parts |) ]
                  |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "" |) |) |)
                ]
              |) in
            let~ after_decimal : Ty.apply (Ty.path "&") [] [ Ty.path "str" ] :=
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                M.get_associated_function (|
                  Ty.path "str",
                  "trim_end_matches",
                  [],
                  [ Ty.path "char" ]
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| after_decimal |) |) |);
                  Value.UnicodeChar 48
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            LogicalOp.or (|
                              LogicalOp.or (|
                                LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "alloc::string::String",
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, amount_str |) ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.path "str",
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| after_decimal |) |)
                                        |)
                                      ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                      "is_some",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::str::iter::Split")
                                                []
                                                [ Ty.path "char" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, parts |) ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)))
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (| Ty.path "str", "len", [], [] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| after_decimal |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (| decimals |)
                                  ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              []
                              [ Ty.path "u64"; Ty.path "solana_program_error::ProgramError" ]
                              [
                                Value.StructTuple
                                  "solana_program_error::ProgramError::InvalidArgument"
                                  []
                                  []
                                  []
                              ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (| Ty.path "alloc::string::String", "push_str", [], [] |),
                [
                  M.borrow (| Pointer.Kind.MutRef, amount_str |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| after_decimal |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.alloc (|
                    Ty.tuple [],
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.call_closure (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            Value.mkStructRecord
                              "core::ops::range::Range"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("start", Value.Integer IntegerKind.Usize 0);
                                ("end_",
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "saturating_sub",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (| decimals |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "str",
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| after_decimal |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |))
                              ]
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let~ iter :
                                Ty.apply
                                  (Ty.path "core::ops::range::Range")
                                  []
                                  [ Ty.path "usize" ] :=
                              M.read (| γ |) in
                            M.read (|
                              M.loop (|
                                Ty.tuple [],
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.never_to_any (| M.read (| M.break (||) |) |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            M.read (|
                                              let~ _ : Ty.tuple [] :=
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_associated_function (|
                                                    Ty.path "alloc::string::String",
                                                    "push",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.MutRef, amount_str |);
                                                    Value.UnicodeChar 48
                                                  ]
                                                |) in
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                              |)
                            |)))
                      ]
                    |)
                  |))
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.path "u64"; Ty.path "solana_program_error::ProgramError" ],
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "u64"; Ty.path "solana_program_error::ProgramError" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u64"; Ty.path "core::num::error::ParseIntError" ],
                  "map_err",
                  [],
                  [
                    Ty.path "solana_program_error::ProgramError";
                    Ty.function
                      [ Ty.path "core::num::error::ParseIntError" ]
                      (Ty.path "solana_program_error::ProgramError")
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::ParseIntError" ],
                    M.get_associated_function (| Ty.path "str", "parse", [], [ Ty.path "u64" ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "alloc::string::String",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, amount_str |) ]
                          |)
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.path "solana_program_error::ProgramError",
                              M.alloc (| Ty.path "core::num::error::ParseIntError", α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (Value.StructTuple
                                      "solana_program_error::ProgramError::InvalidArgument"
                                      []
                                      []
                                      []))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |)
          |)))
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_try_ui_amount_into_amount :
  M.IsFunction.C "spl_token::try_ui_amount_into_amount" try_ui_amount_into_amount.
Admitted.
Global Typeclasses Opaque try_ui_amount_into_amount.
