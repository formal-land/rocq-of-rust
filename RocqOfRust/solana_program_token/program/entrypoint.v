(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

Module entrypoint.
  (*
  fn process_instruction(
      program_id: &Pubkey,
      accounts: &[AccountInfo],
      instruction_data: &[u8],
  ) -> ProgramResult {
      if let Err(error) = Processor::process(program_id, accounts, instruction_data) {
          // catch the error so we can print it
          msg!(error.to_str::<TokenError>());
          return Err(error);
      }
      Ok(())
  }
  *)
  Definition process_instruction (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ program_id; accounts; instruction_data ] =>
      ltac:(M.monadic
        (let program_id :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "solana_address::Address" ],
            program_id
          |) in
        let accounts :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "solana_account_info::AccountInfo" ] ],
            accounts
          |) in
        let instruction_data :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            instruction_data
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                              M.get_associated_function (|
                                Ty.path "spl_token::processor::Processor",
                                "process",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| program_id |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| accounts |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| instruction_data |) |)
                                |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let error :=
                          M.copy (| Ty.path "solana_program_error::ProgramError", γ0_0 |) in
                        M.never_to_any (|
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_function (| "solana_msg::sol_log", [], [] |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                        M.get_associated_function (|
                                          Ty.path "solana_program_error::ProgramError",
                                          "to_str",
                                          [],
                                          [ Ty.path "spl_token_interface::error::TokenError" ]
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, error |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |) in
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                                [ M.read (| error |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ],
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [ Ty.tuple []; Ty.path "solana_program_error::ProgramError" ]
                  [ Value.Tuple [] ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_process_instruction :
    M.IsFunction.C "spl_token::entrypoint::process_instruction" process_instruction.
  Admitted.
  Global Typeclasses Opaque process_instruction.
End entrypoint.
